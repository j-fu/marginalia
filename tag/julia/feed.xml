<?xml version="1.0" encoding="UTF-8"?>

<rss version="2.0"
  xmlns:content="http://purl.org/rss/1.0/modules/content/"
  xmlns:dc="http://purl.org/dc/elements/1.1/"
  xmlns:media="http://search.yahoo.com/mrss/"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:georss="http://www.georss.org/georss">

  <channel>
    <title>
      <![CDATA[  Marginalia  ]]>
    </title>
    <link> https://j-fu.github.io/marginalia/ </link>
    <description>
      <![CDATA[  Remarks on computing &amp; stuff  ]]>
    </description>
    <atom:link
      href="https://j-fu.github.io/marginalia/feed.xml"
      rel="self"
      type="application/rss+xml" />


<item>
  <title>
    <![CDATA[    ]]>
  </title>
  <link> https://j-fu.github.io/marginalia/julia/scalingtest/index.html </link>
  <guid> https://j-fu.github.io/marginalia/julia/scalingtest/index.html </guid>
  <description>
    <![CDATA[  Sparse matrix solver scaling  ]]>
  </description>  
  
  <content:encoded>
    <![CDATA[  <h1 id="13633231208144796923"></h1><iframe style="height:9800px" width="100%" frameborder="0" src="https://j-fu.github.io/marginalia/assets/scalingtest2.html"> </iframe> ]]>
  </content:encoded>
    
  <pubDate>Thu, 13 Jul 2023 00:00:00 +0000</pubDate>  
  
  
  <atom:author>
    <atom:name>JÃ¼rgen Fuhrmann</atom:name>
  </atom:author>
        
</item>

<item>
  <title>
    <![CDATA[  Julia: Package Workflow  ]]>
  </title>
  <link> https://j-fu.github.io/marginalia/julia/package-workflow/index.html </link>
  <guid> https://j-fu.github.io/marginalia/julia/package-workflow/index.html </guid>
  <description>
    <![CDATA[  Julia: Package Workflow.  ]]>
  </description>  
  
  <content:encoded>
    <![CDATA[  <h1 id="julia_package_workflow">Julia: Package Workflow</h1>
<p>&#40;Draft&#41;</p>
<div class="franklin-toc"><ol><li>Intro</li><li>Starting a package<ol><li>Starting a package as part of an application project</li><li>Starting a package repository</li></ol></li><li>Tests</li><li>Continuous Integration</li><li>Providing <ol><li>Using  a package under development</li><li>Registration of a new package or a new version in a local registry</li><li>Without write access to the registry</li><li>With write access to this repository</li><li>Using the General registry</li><li>Naming and versioning</li></ol></li><li>Other useful introductions</li></ol></div>
<h2 id="intro">Intro</h2>
<p>This post is work in progress. May be one of the other useful introductions will be more useful at the moment.</p>
<p>For general terminology, see the <a href="https://pkgdocs.julialang.org/v1/glossary/#Glossary">package manager glossary</a>. According to this, here, we assume that a  <em>package</em> is Julia code which is supposed to be used by other projects, applications or packages.</p>
<p>When developing Julia packages it is advisable to set the environment variable <a href="https://pkgdocs.julialang.org/v1/api/#Pkg.develop"><code>JULIA_PKG_DEVDIR</code></a> to a reasonable path. All Julia packages under development will reside there, and for a particular package, we refer to its corresponding <code>package_dir</code>  during this post.</p>
<h2 id="starting_a_package">Starting a package</h2>
<p>See also the <a href="https://pkgdocs.julialang.org/v1/creating-packages/">Pkg documentation</a></p>
<h3 id="starting_a_package_as_part_of_an_application_project">Starting a package as part of an application project</h3>
<p>Often, packages evolve during the development of larger application, when it becomes clear that some part of it provides some well defined functionality which can be formulated with its own API.  Local packages within an application project allow to start the package development process in such a situation.  For this structure, see <a href="https://j-fu.github.io/marginalia/julia/project-workflow#new_packages_can_evolve_from_the_projec_code">my previous post</a>.</p>
<h3 id="starting_a_package_repository">Starting a package repository</h3>
<p>Typically, each Julia package resides in its own git repository &#40;other configurations are <a href="https://discourse.julialang.org/t/usage-of-subdirectories-to-store-multiple-packages-in-a-single-repo/55534">possible</a>&#41;.</p>
<p>Create an  empty repository <code>NewPackageName.jl</code> on a server with <code>git_url</code></p>
<pre><code class="language-julia">&#36; cd &#36;JULIA_PKG_DEVDIR
&#36; julia
pkg&gt; generate NewPackageName
julia&gt; exit&#40;&#41;
cd NewPackageName
git init
git add remote origin git_url
git add .</code></pre>
<p>Julia packages have a fixed structure which includes</p>
<ul>
<li><p><a href="https://pkgdocs.julialang.org/v1/toml-files/#Project.toml"><code>Project.toml</code></a>: description of dependencies. This also provides the package with its own environment during development. Furthermore, it contains the universally unique identifier &#40;UUID&#41; used to identify the package and its name, author and version number.</p>
</li>
<li><p><code>README.md</code>: Short information about the package</p>
</li>
<li><p><code>LICENSE</code>: License information. Should be one of the <a href="https://opensource.org/licenses">OSI approved</a> open source licenses if the package shall be registered with the Julia General Registry</p>
</li>
<li><p><code>src</code>: subdirectory containing code</p>
<ul>
<li><p><code>src/NewPackageName.jl</code>: Julia source file which must contain a module <code>NewPackageName</code> where all package code resides. It may include further source code files.</p>
</li>
</ul>
</li>
<li><p><code>test</code>: subdirectory containing test code</p>
<ul>
<li><p><code>test/runtests.jl</code>: script for running tests</p>
</li>
<li><p><code>test/Project.toml</code>: environment file containing test only dependencies</p>
</li>
</ul>
</li>
<li><p><code>docs</code>: subdirectory containing documentation </p>
<ul>
<li><p><code>docs/make.jl</code>: script for builidng documentation based on Documenter.jl</p>
</li>
<li><p><code>docs/Project.toml</code>: environment file containing dependencies for documentation</p>
</li>
</ul>
</li>
<li><p>Configuration files for Continuous Integration</p>
</li>
</ul>
<p>A  <a href="https://pkgdocs.julialang.org/v1/toml-files/#Project.toml"><code>Manifest.toml</code></a> file is created as soon as the package environment is instantiated. It contains the full metadata of  all package dependencies. This file <em>should not be tracked by git</em>. Instead, the <code>Project.toml</code> shall contain a <code>&#91;compat&#93;</code> section which inform the package resolver about the compatibility with different versions of dependencies.</p>
<p>Instead of invoking <code>pkg&gt; generate NewPackageName</code>, a more comprehensive initial package structure can be be created by cloning  <a href="https://github.com/JuliaLang/Example.jl">Example.jl</a> or with <a href="https://github.com/invenia/PkgTemplates.jl">PkgTemplates.jl</a>. These also create the necessary files for controlling automatic CI tests on github/gitlab.</p>
<h2 id="tests">Tests</h2>
<p>See also the <a href="https://pkgdocs.julialang.org/v1/creating-packages/#Adding-tests-to-the-package">Pkg documentation</a>.</p>
<p>The files in <code>test</code> provide the environment and the code to run tests of the functions implemented in the package. While it is hard to have 100&#37; test coverage of the package functionality, one should strive to achieve this goal. Besides of the obvious reasons of reproducibility,  peer pressure etc., sufficient test coverage helps to keep a package author sane. Imagine the need to change something in the  package three years after the last serious work on it...</p>
<p>It is quite possible that tests have more dependencies than the package itself. Therefore Julia packages can have their own test environment in <code>test/Project.toml</code>. The <code>runtests.jl</code> file contains the code for the tests. All code called from the <a href="https://docs.julialang.org/en/v1/stdlib/Test/#Test.@test"><code>@test</code></a> macro is part of the test coverage. A simple file <code>runtests.jl</code> contains e.g.:</p>
<pre><code class="language-julia">using Test@test 1&#43;1 &#61;&#61; 2</code></pre>
<p>Tests code can be called in different ways. In the package root environment:</p>
<pre><code class="language-julia">julia&gt; Pkg.test&#40;&#41;</code></pre>
<p>or from the <code>Pkg</code> prompt:</p>
<pre><code class="language-julia">&#93; test</code></pre>
<p>The seame test can be invoked also in any environment with the package added: </p>
<pre><code class="language-julia">julia&gt; Pkg.test&#40;&quot;MyPackageName&quot;&#41;</code></pre>
<p>or</p>
<pre><code class="language-julia">&#93; test MyPackageName</code></pre>
<h2 id="continuous_integration">Continuous Integration</h2>
<p>Your package tests sucessfully run on your linux laptop. But how can you be sure that they also run on Mac and Windows ? And, you want to show off with a good test coverage helping to build up trust in your work.</p>
<p>The solution ?  Run your tests on different systems via <a href="https://github.com/features/actions">github actions</a> and <a href="https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/adding-a-workflow-status-badge">show off</a> the result.</p>
<p>In order to achieve this, it is sufficient to add a file</p>
<pre><code class="language-julia">.github/workflows/ci.yml</code></pre>
<p>Alternatively, this can be done on <a href="https://discourse.julialang.org/t/julia-and-gitlab-self-hosted-a-state-of-the-art/86685">gitlab</a> as well.</p>
<h2 id="providing">Providing </h2>
<h3 id="using_a_package_under_development">Using  a package under development</h3>
<p>While the package is unregistered you can add it to the environment of a project:</p>
<pre><code class="language-julia">&#36; cd project_dir
&#36; julia --project&#61;@.
pkg&gt; add git_url</code></pre>
<p>In this case, the version in the git repository on the server is used via a shallow clone &#40;clone without versioning information&#41; created in <code>&#36;HOME/.julia/packages</code>. If you use</p>
<pre><code class="language-julia">pkg&gt; dev git_url</code></pre>
<p>instead, a full clone is created in <code>&#36;JULIA_PKG_DEVDIR</code> and used. If the corresponding subdirectory in <code>JULIA_PKG_DEVDIR</code> does not exist, it will be checked out from <code>git_url</code>. The same would happen with registered packages added by name.</p>
<h3 id="registration_of_a_new_package_or_a_new_version_in_a_local_registry">Registration of a new package or a new version in a local registry</h3>
<p>We assume to speak about <code>MyRegistry</code> as an example, but generally this is true for all registries. </p>
<h3 id="without_write_access_to_the_registry">Without write access to the registry</h3>
<p>Send an  email to  one of  the admins  containing the  git url  of the corresponding repository singnaling the advance of a new version.  The <code>Project.toml</code> file already should contain the new version number.</p>
<h3 id="with_write_access_to_this_repository">With write access to this repository</h3>
<p>Add the <a href="https://github.com/GunnarFarneback/LocalRegistry.jl">LocalRegistry.jl</a> package to your environment</p>
<pre><code class="language-julia">pkg&gt;  add LocalRegistry</code></pre>
<p>For a new package <code>X.jl</code> or a new version thereof, first obtain a clone, either by checking it out via its url, or by adding it to the environment, getting into develop mode and updating it:</p>
<pre><code class="language-julia">pkg&gt; add X
pkg&gt; develop X
pkg&gt; update X # not clear if really necessary</code></pre>
<p>Then, you will be able to register a new version based on the updated version number in <code>Project.toml</code>:</p>
<pre><code class="language-julia">julia&gt; using X
julia&gt; using LocalRegistry
julia&gt; LocalRegistry.register&#40;X,&quot;MyRegistry&quot;,push&#61;true&#41;</code></pre>
<p>This assumes that the remote origin of the local clone in <code>.julia/registries/MyRegistry</code> has been modified to <code>git@github.com:me/MyRegistry</code>. The <code>push&#61;true</code> can be omitted, in this case, <code>LocalRegistry.Register</code> results in a commit to the local copy which you can push later.</p>
<p>After this, do not forget to create a tag in your repository marking the version <code>x.y.z</code> of the package:</p>
<pre><code class="language-julia">&#36; git tag vx.y.z</code></pre>
<h3 id="using_the_general_registry">Using the General registry</h3>
<p>Registring packages in the general registry assumes full compliance to a number of rules:</p>
<ul>
<li><p>Package is deployed with automatic testing on github &#40;at least this is the current practice&#41; with <a href="https://juliadocs.github.io/Documenter.jl/stable/man/hosting/index.html">travis, deploydocs etc. enabled</a></p>
</li>
<li><p>Don&#39;t forget compat info for  julia and all packages  in Project.toml</p>
</li>
<li><p>Proper versioning sequence</p>
</li>
<li><p>Must wait 3 days for merge for  new package</p>
</li>
<li><p>Must wait \(\approx\) 1 hour for new version</p>
</li>
</ul>
<p>All of this is automatically handeled by the <a href="https://github.com/JuliaRegistries/Registrator.jl">JuliaRegistrator</a></p><div class="img-small">
<img src="https://raw.githubusercontent.com/JuliaRegistries/Registrator.jl/master/graphics/logo.png">
</div><p>It needs to be installed as a github app in for the package repository.</p>
<h3 id="naming_and_versioning">Naming and versioning</h3>
<ul>
<li><p>Registration in the general registry starts with version 0.1.0, all deviations from this will create extra work upon registration in the general registry.</p>
</li>
<li><p>Start registration Registering with JuliaEgistrator</p>
</li>
<li><p>Either name a &quot;budding package&quot; &#40;e.g. Ants.jl&#41; accordingly: AntsPrototype.jl, Ants0.jl </p>
</li>
</ul>
<h2 id="other_useful_introductions">Other useful introductions</h2>
<ul>
<li><p><a href="https://jaantollander.com/post/how-to-create-software-packages-with-julia-language/">Jaan Tollander de Balsch: How to Create Software Packages with Julia Language</a></p>
</li>
<li><p><a href="https://sdobber.github.io/juliapackage/">SÃ¶ren DobberschÃ¼tz: Tips and tricks to register your first Julia package</a></p>
</li>
<li><p><a href="https://medium.com/analytics-vidhya/an-introduction-to-continuous-integration-github-actions-for-julia-1a5a1a6e64d6">Kim Fung: An Introduction to Continuous Integration &amp; GitHub Actions for Julia</a></p>
</li>
<li><p><a href="https://medium.com/coffee-in-a-klein-bottle/developing-your-julia-package-682c1d309507">DSB: Developing your Julia package</a></p>
</li>
<li><p><a href="https://www.stochasticlifestyle.com/developing-julia-packages/">Christopher Rackauckas: Developing Julia packages &#40;video&#41;</a></p>
</li>
</ul>
<p>
<hr size="5" noshade>
 <strong>Update history</strong></p>
<ul>
<li><p>2023-04-24: Draft updated &#43; made public</p>
</li>
<li><p>2022-12-06: First draft</p>
</li>
</ul>
 ]]>
  </content:encoded>
    
  <pubDate>Mon, 24 Apr 2023 00:00:00 +0000</pubDate>  
  
  
  <atom:author>
    <atom:name>JÃ¼rgen Fuhrmann</atom:name>
  </atom:author>
        
</item>

<item>
  <title>
    <![CDATA[  Julia: Introductory material  ]]>
  </title>
  <link> https://j-fu.github.io/marginalia/julia/intro-material/index.html </link>
  <guid> https://j-fu.github.io/marginalia/julia/intro-material/index.html </guid>
  <description>
    <![CDATA[  Julia: Introductory material.  ]]>
  </description>  
  
  <content:encoded>
    <![CDATA[  <h1 id="julia_introductory_material">Julia: Introductory material</h1>
<p>This is a collection of online references pointing at introductory material for the Julia language.If you look for further online resources, please ensure that they are for Julia 1.0 and newer. This is best achieved by looking for material not older than 2019.</p>
<div class="franklin-toc"><ol><li>Installation</li><li>Learning<ol><li>Resources curated by the Julia development team.</li><li>More learning resources </li></ol></li><li>Introductory material from my TU Berlin courses  and other talks &#40;videos &#43; Pluto notebooks&#41;</li><li>Editing</li></ol></div>
<h2 id="installation">Installation</h2>
<p>Install the latest stable version via the Julia <a href="https://julialang.org">Homepage</a>. Julia devs recommend not to use the Julia versions provided from other sources &#40;like Homebrew, various Linux package managers&#41;. <a href="https://github.com/JuliaLang/juliaup">juliaup</a> provides another flexible way to install Julia and to switch between versions.</p>
<h2 id="learning">Learning</h2>
<h3 id="resources_curated_by_the_julia_development_team">Resources curated by the Julia development team.</h3>
<ul>
<li><p><a href="https://docs.julialang.org/en/v1/">Documentation</a></p>
<ul>
<li><p><a href="https://docs.julialang.org/en/v1/manual/getting-started/">Getting started</a></p>
</li>
<li><p>Noteworthy differences from <a href="https://docs.julialang.org/en/v1/manual/noteworthy-differences/#Noteworthy-differences-from-MATLAB-1">Matlab</a>, <a href="https://docs.julialang.org/en/v1/manual/noteworthy-differences/#Noteworthy-differences-from-R-1">R</a>, <a href="https://docs.julialang.org/en/v1/manual/noteworthy-differences/?highlight&#61;matlab#Noteworthy-differences-from-Python-1">Python</a>, <a href="https://docs.julialang.org/en/v1/manual/noteworthy-differences/#Noteworthy-differences-from-C/C">C/C&#43;&#43;</a></p>
</li>
</ul>
</li>
<li><p><a href="https://julialang.org/learning/">Curated learning resources</a></p>
</li>
<li><p>Julia is evolving. New versions in the 1.x range introduce many important additions and non-breaking changes. Many important Julia packages require at least the current long term service &#40;LTS&#41; version 1.6. </p>
<ul>
<li><p>Julia version highlights: <a href="https://julialang.org/blog/2020/08/julia-1.5-highlights/">1.5</a>, <a href="https://julialang.org/blog/2021/03/julia-1.6-highlights/">1.6</a>, <a href="https://julialang.org/blog/2021/11/julia-1.7-highlights/">1.7</a>, <a href="https://julialang.org/blog/2022/08/julia-1.8-highlights/">1.8</a> <a href="https://julialang.org/blog/2023/04/julia-1.9-highlights/">1.9</a></p>
</li>
<li><p><a href="https://towardsdatascience.com/why-julia-2-0-isnt-coming-anytime-soon-and-why-that-is-a-good-thing-641ae3d2a177">Why Julia 2.0 Isnâ€™t Coming Anytime Soon</a></p>
</li>
</ul>
</li>
</ul>
<h3 id="more_learning_resources">More learning resources </h3>
<ul>
<li><p><a href="https://www.youtube.com/c/juliafortalentedamateurs/videos">Julia for Talented Amateurs</a>: Actively maintained collection of video tutorials for many different aspects of Julia</p>
</li>
<li><p><a href="https://en.wikibooks.org/wiki/Introducing_Julia">WikiBook</a></p>
</li>
<li><p>The book <a href="https://web.stanford.edu/~boyd/vmls/">Introduction to Applied Linear Algebra â€“ Vectors, Matrices, and Least Squares</a> by Stephen Boyd and Lieven Vandenberghe has a <a href="http://vmls-book.stanford.edu/vmls-julia-companion.pdf">Julia companion</a></p>
</li>
<li><p><a href="https://julia.quantecon.org/index_toc.html">QuantEcon</a> tutorial with focus on economics and statistics</p>
</li>
<li><p><a href="https://juliadocs.github.io/Julia-Cheat-Sheet/">Cheat Sheet</a></p>
</li>
<li><p><a href="https://cheatsheets.quantecon.org/">Matlab-Julia-Python cheat sheet</a></p>
</li>
<li><p><a href="https://www.manning.com/books/julia-as-a-second-language">Julia as a second language</a> by Erik Engheim</p>
</li>
</ul>
<h2 id="introductory_material_from_my_tu_berlin_courses_and_other_talks_videos_pluto_notebooks">Introductory material from my TU Berlin courses  and other talks &#40;videos &#43; Pluto notebooks&#41;</h2>
<ul>
<li><p><a href="https://av.tib.eu/media/57515">The Julia programming language - an overview</a>. Talk at <a href="https://www.wias-berlin.de/workshops/MMSDays22/">Leibniz MMS Days 2022</a>.</p>
</li>
<li><p><a href="https://www.wias-berlin.de/people/fuhrmann/SciComp-WS2122/week1/#julia_pluto_installation">Julia&#43;Pluto installation &#40;Winter 21/22&#41;</a></p>
</li>
<li><p><a href="https://www.wias-berlin.de/people/fuhrmann/SciComp-WS2122/week1/#first_contact_pluto">First contact: Pluto &#40;Winter 21/22&#41;</a></p>
</li>
<li><p><a href="https://www.wias-berlin.de/people/fuhrmann/SciComp-WS2122/week1/#first_contact_julia">First contact: Julia &#40;Winter 21/22&#41;</a></p>
</li>
<li><p><a href="https://www.wias-berlin.de/people/fuhrmann/SciComp-WS2122/week2/#julia_type_system">Julia type system &#40;Winter 21/22&#41;</a></p>
</li>
<li><p><a href="https://www.wias-berlin.de/people/fuhrmann/SciComp-WS2122/week2/#just-in-time_jit_compilation_and_performance">JIT compilation and performance &#40;Winter 21/22&#41;</a></p>
</li>
<li><p><a href="https://www.wias-berlin.de/people/fuhrmann/SciComp-WS2122/week2/#julia_interoperability">Julia interoperabillity &#40;Winter 21/22&#41;</a></p>
</li>
<li><p><a href="https://www.wias-berlin.de/people/fuhrmann/SciComp-WS2122/week3/#stack_heap_allocations">Stack, heap, allocations &#40;Winter 21/22&#41;</a></p>
</li>
<li><p><a href="https://www.wias-berlin.de/people/fuhrmann/AdSciComp-WS2223/week3/#reproducibility_infrastructure_of_the_julia_language">Reproducibility infrastructure of the Julia language &#40;Winter 22/23&#41;</a></p>
</li>
<li><p><a href="https://www.wias-berlin.de/people/fuhrmann/AdSciComp-WS2223/week3/#plotting_in_julia">Plotting in Julia &#40;Winter 22/23&#41;</a></p>
</li>
</ul>
<h2 id="editing">Editing</h2>
<ul>
<li><p><a href="https://github.com/julia-vscode/julia-vscode">Visual Studio Code extension</a></p>
</li>
<li><p><a href="https://github.com/fonsp/Pluto.jl">Pluto notebooks</a>;    How to install Julia and Pluto: <a href="https://www.youtube.com/watch?v&#61;OOjKEgbt8AI">MIT course video</a></p>
</li>
<li><p><a href="https://github.com/JuliaEditorSupport/julia-emacs">Emacs support</a></p>
</li>
</ul><hr size="5" noshade><p><strong>Update history</strong></p>
<ul>
<li><p>2023-10-17: Julia as a second language, semester info</p>
</li>
</ul>
 ]]>
  </content:encoded>
    
  <pubDate>Sun, 23 Apr 2023 00:00:00 +0000</pubDate>  
  
  
  <atom:author>
    <atom:name>JÃ¼rgen Fuhrmann</atom:name>
  </atom:author>
        
</item>

<item>
  <title>
    <![CDATA[    ]]>
  </title>
  <link> https://j-fu.github.io/marginalia/julia/sparsejac/index.html </link>
  <guid> https://j-fu.github.io/marginalia/julia/sparsejac/index.html </guid>
  <description>
    <![CDATA[  Calculating sparse jacobians  ]]>
  </description>  
  
  <content:encoded>
    <![CDATA[  <h1 id="13633231208144796923"></h1><iframe style="height:9800px" width="100%" frameborder="0" src="https://j-fu.github.io/marginalia/assets/sparsejac.html"> </iframe> ]]>
  </content:encoded>
    
  <pubDate>Sat, 22 Oct 2022 00:00:00 +0000</pubDate>  
  
  
  <atom:author>
    <atom:name>JÃ¼rgen Fuhrmann</atom:name>
  </atom:author>
        
</item>

<item>
  <title>
    <![CDATA[  Julia: Project Workflow  ]]>
  </title>
  <link> https://j-fu.github.io/marginalia/julia/project-workflow/index.html </link>
  <guid> https://j-fu.github.io/marginalia/julia/project-workflow/index.html </guid>
  <description>
    <![CDATA[  Julia: Project Workflow.  ]]>
  </description>  
  
  <content:encoded>
    <![CDATA[  <h1 id="julia_project_workflow">Julia: Project Workflow</h1>
<p><div class="franklin-toc"><ol><li>Rationale</li><li>Recommendations<ol><li>Generate the project directory itself as a package</li><li>New packages can evolve from the project code</li><li>Always start Julia from the package root</li><li>Activate the project environment in notebooks</li><li>Consider using DrWatson.jl</li><li>A sample project tree</li></ol></li><li>Summary</li></ol></div> </p>
<p>The term &quot;project&quot; in this post corresponds to the term &quot;application&quot; in <a href="https://pkgdocs.julialang.org/v1/glossary/#Glossary">package manager glossary</a></p>
<h2 id="rationale">Rationale</h2>
<p>Some ideas on basic julia workflow  are given  <a href="https://j-fu.github.io/marginalia/julia/basic-workflow">here</a>. For a larger project, structuring of the project code is essential for many reasons, some of them are:</p>
<ul>
<li><p>Different project scripts and Pluto notebooks may share some parts of the code, and you want to avoid <a href="https://en.wikipedia.org/wiki/Don&#37;27t_repeat_yourself">repeating yourself</a>.</p>
</li>
<li><p>Modularization of the project code should facilitate maintainability and extendability.</p>
</li>
<li><p>May be some of the code slowly turns into a package.</p>
</li>
<li><p>You want to have unit testing available in the project.</p>
</li>
<li><p>The whole project directory <em>still</em> shall be shareable with collaborators in a reproducible way.</p>
</li>
</ul>
<h2 id="recommendations">Recommendations</h2>
<p>The following recommendations are partially inspired by B. Kaminski&#39;s post on  <a href="https://bkamins.github.io/julialang/2020/05/18/project-workflow.html">project workflow</a> and  the  <a href="https://github.com/JuliaDynamics/DrWatson.jl">DrWatson.jl</a> package by G. Datseris.</p>
<h3 id="generate_the_project_directory_itself_as_a_package">Generate the project directory itself as a package</h3>
<p>Name this e.g. <code>MyProject</code>. Use<a href="https://pkgdocs.julialang.org/v1/creating-packages/"><code>Pkg.generate</code></a> or <a href="https://github.com/invenia/PkgTemplates.jl">PkgTemplates.jl</a>. Unlinke a published Julia package, this  <em>project-package</em> will remain not be registered in a Julia package registry, its code will be shared directly via git repository urls.  Developing the project in such a project-package has the following advantages:</p>
<ul>
<li><p>Straightforward way to share  the code in the <code>src</code> folder among different project scripts and notebooks based on one shared environment via <code>using MyProject</code>.</p>
</li>
<li><p>Straightforward availability of Julia&#39;s  test and documentation functionality for the project.</p>
</li>
<li><p>Reproducibility due to dependencies recorded in the project environment &#40;files <code>Project.toml</code> and <code>Manifest.toml</code>&#41;.</p>
</li>
</ul>
<h3 id="new_packages_can_evolve_from_the_project_code">New packages can evolve from the project code</h3>
<p>For this purpose, optionally you can have a folder <code>packages</code> which contains other sub-packages which potentially can evolve into standalone, even registered packages. As <a href="https://github.com/JuliaLang/Pkg.jl/issues/1214">relative paths are recorded in Manifest.toml</a>, these are made available within the  project via <code>Pkg.develop&#40;path&#61;&quot;packages/MySubPackage&quot;&#41;</code>. This way, the  whole project  tree including sub-packages  will stay relocateable.</p>
<ul>
<li><p>This allows for easy start of low key package development. At a later stage, <code>MySubPackage</code> could be registered as a Julia package while still residing in the project tree, or even removed from the project tree without affecting  scripts depending on it â€“ once registered, the package can be added in to the project environment via <code>Pkg.add</code> instead of <code>Pkg.develop</code>.</p>
</li>
</ul>
<h3 id="always_start_julia_from_the_package_root">Always start Julia from the package root</h3>
<ul>
<li><p>When working with the project, always run julia from the package root with the package environment activated: <code>julia --project&#61;.</code> </p>
</li>
</ul>
<h3 id="activate_the_project_environment_in_notebooks">Activate the project environment in notebooks</h3>
<p>Project specific Pluto notebooks would reside in a <code>notebooks</code> subdirectory  and call <code>Pkg.activate&#40;joinpath&#40;@__DIR__,&quot;..&quot;&#41;&#41;</code> in their respective Pkg cell to activate the <code>MyProject</code> environment.  As a consequence, Pluto&#39;s in-built package manager will be disabled and the project specific notebooks will share the <code>MyProject</code> environment and <em>cannot be shared independent from the <code>MyProject</code> tree</em> &#40;If independent sharing is desired, common project code can be collected into a package residing in <code>packages</code> and registered in a registry; registering <code>MyProject</code> itself as a package is not recommended.  â€“ More about this in another post&#41;.</p>
<h3 id="consider_using_drwatsonjl">Consider using DrWatson.jl</h3>
<p>You may use <a href="https://github.com/JuliaDynamics/DrWatson.jl">DrWatson.jl</a> for managing subdirectory access, simulation results and version tagging. By explicitely activating the project environment at the start of Julia or in the notebook Pkg cell, you can avoid <code>@quickactivate</code> and  avoid putting <code>using DrWatson</code> into script files and notebooks for the sole purpose of activating the common environment. See also <a href="https://github.com/JuliaDynamics/DrWatson.jl/issues/261">this discussion</a>.</p>
<h3 id="a_sample_project_tree">A sample project tree</h3>
<p>A sample project tree could e.g. look like this</p>
<pre><code class="language-julia">MyProject
â”œâ”€â”€ LICENSE
â”œâ”€â”€ Manifest.toml
â”œâ”€â”€ notebooks
â”‚Â Â  â””â”€â”€ demo-notebook.jl
â”œâ”€â”€ packages
â”‚Â Â  â””â”€â”€ MySubPackage
â”‚Â Â      â”œâ”€â”€ Manifest.toml
â”‚Â Â      â”œâ”€â”€ Project.toml
â”‚Â Â      â”œâ”€â”€ src
â”‚Â Â      â”‚Â Â  â””â”€â”€ MySubPackage.jl
â”‚Â Â      â””â”€â”€ test
â”‚Â Â          â””â”€â”€ runtests.jl
â”œâ”€â”€ papers
â”œâ”€â”€ Project.toml
â”œâ”€â”€ README.md
â”œâ”€â”€ scripts
â”‚Â Â  â””â”€â”€ demo-script.jl
â”œâ”€â”€ src
â”‚Â Â  â””â”€â”€ MyProject.jl
â””â”€â”€ test
    â””â”€â”€ runtests.jl</code></pre>
<p>You can download the Julia script <a href="https://j-fu.github.io/marginalia/assets/genproject.jl">genproject.jl</a> and generate this structure a subdirectory on your computer via</p>
<pre><code class="language-julia">julia --compile&#61;min genproject.jl name_of_your_project</code></pre>
<p>Feel free to adapt the generated directory tree to your needs and don&#39;t forget to make a git repository out of it as early as possible.</p>
<h2 id="summary">Summary</h2>
<ul>
<li><p>Script functionality should be developed in functions, avoiding global variables</p>
</li>
<li><p>Create a project specific environment as a project-package</p>
</li>
<li><p>Use the REPL and  Revise.jl, start julia in the activated project environment</p>
</li>
<li><p>Place shared code among project specific  scripts or  notebooks either in the <code>src</code> subdirectory as part of the project-package, or in a  sub-package in a subdirectory of the project-package</p>
</li>
<li><p>Separate namespaces of scripts by using  modules</p>
</li>
<li><p>Activate the shared project environment of the project-package in project specific Pluto notebooks. </p>
</li>
<li><p>Write tests and examples</p>
</li>
</ul>
<p>By taking advantage of Julia&#39;s best-in-class package management facilities, the proposed approach goes a long way in the direction of maintaining sustainable research software. From a <a href="https://de.slideshare.net/andreas.zeller/sustainable-research-software">talk by A. Zeller</a>:</p>
<ol>
<li><p>Have a repo âœ“</p>
</li>
<li><p>Anyone can build âœ“</p>
</li>
<li><p>Have tests âœ“</p>
</li>
<li><p>Be open for extensions âœ“</p>
</li>
<li><p>Have examples âœ“</p>
</li>
</ol>
<p>
<hr size="5" noshade>
 <strong>Update history</strong></p>
<ul>
<li><p>2023-04-24: Intermediate headers</p>
</li>
<li><p>2022-02-09: RSS</p>
</li>
<li><p>2021-12-02: The term &quot;project&quot; in this post corresponds to the term &quot;application&quot; in <a href="https://pkgdocs.julialang.org/v1/glossary/#Glossary">package manager glossary</a>.</p>
</li>
<li><p>2021-11-15: Initial version </p>
</li>
</ul>
 ]]>
  </content:encoded>
    
  <pubDate>Wed, 09 Feb 2022 00:00:00 +0000</pubDate>  
  
  
  <atom:author>
    <atom:name>JÃ¼rgen Fuhrmann</atom:name>
  </atom:author>
        
</item>

<item>
  <title>
    <![CDATA[    ]]>
  </title>
  <link> https://j-fu.github.io/marginalia/julia/unionize/index.html </link>
  <guid> https://j-fu.github.io/marginalia/julia/unionize/index.html </guid>
  <description>
    <![CDATA[  Julia: Unionize your collections&#33;  ]]>
  </description>  
  
  <content:encoded>
    <![CDATA[  <h1 id="13633231208144796923"></h1><iframe style="height:10500px" width="100%" frameborder="0" src="https://j-fu.github.io/marginalia/assets/unionize.html"> </iframe> ]]>
  </content:encoded>
    
  <pubDate>Wed, 09 Feb 2022 00:00:00 +0000</pubDate>  
  
  
  <atom:author>
    <atom:name>JÃ¼rgen Fuhrmann</atom:name>
  </atom:author>
        
</item>

<item>
  <title>
    <![CDATA[  Julia: Basic Workflow  ]]>
  </title>
  <link> https://j-fu.github.io/marginalia/julia/basic-workflow/index.html </link>
  <guid> https://j-fu.github.io/marginalia/julia/basic-workflow/index.html </guid>
  <description>
    <![CDATA[  Julia: Basic Workflow.  ]]>
  </description>  
  
  <content:encoded>
    <![CDATA[  <h1 id="julia_basic_workflow">Julia: Basic Workflow</h1>
<p><div class="franklin-toc"><ol><li>Never leave Julia and  write code in functions</li><li>Use Revise.jl to reload modified code</li><li>Record your project dependencies in reproducible environments<ol><li>Global environment</li><li>Local environments</li><li>Shared &#40;&quot;<code>@</code>&quot;&#41; Environments</li><li>Further info</li></ol></li></ol></div> </p>
<p>These workflow hints have been developed from my own experience and are essentially an illustration of the <a href="https://docs.julialang.org/en/v1/manual/workflow-tips">workflow tips</a>  found in the Julia documentation. </p>
<h2 id="never_leave_julia_and_write_code_in_functions">Never leave Julia and  write code in functions</h2>
<p>Many available Julia examples and  the mindset influenced by Matlab or Python suggest  that code is written in scripts where  computations are performed in the global context. E.g.  a script <code>MyScript.jl</code> would look like:</p>
<pre><code class="language-julia">using Package1
using Package2# computations here
...</code></pre>
<p>and executed like</p>
<pre><code class="language-julia">&#36; julia MyScript.jl</code></pre>
<p>However, for Julia this is a bad idea for at  least two reasons:</p>
<ul>
<li><p>Type-stable action of Julia&#39;s just-in-time compiler is possible only for functions, so this code does not optimize well</p>
</li>
<li><p>One encounters precompilation time hiatus when running after each modified  version</p>
</li>
</ul>
<p>Suggestions:</p>
<ul>
<li><p><a href="https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-global-variables">Avoid  untyped global variables</a> and develop any code in functions. E.g. <code>MyScript.jl</code> could look like:</p>
</li>
</ul>
<pre><code class="language-julia">using Package1
using Package2function main&#40;; kwarg1&#61;1, kwarg2&#61;2&#41;
 # action here 
end</code></pre>
<ul>
<li><p>Always invoke the code from within a running julia instance. In this   case you encounter the <a href="https://docs.julialang.org/en/v1/manual/workflow-tips/#REPL-based-workflow">Read-Eval-Print-Loop &#40;REPL&#41;</a> of Julia. You don&#39;t need to leave julia for restarting modified code &#40;except in the case when you re-define a constant or a struct&#41;. Just reload the code by repeating the <code>include</code> statement:</p>
</li>
</ul>
<pre><code class="language-julia">&#36; julia
julia&gt; include&#40;&quot;MyScript.jl&quot;&#41;
julia&gt; main&#40;kwarg1&#61;5&#41;</code></pre>
<ul>
<li><p>Think about wrapping code into modules. The previous example can be enhanced by wrapping the code of the script into a module.  This has the advantage that you can load different scripts into the same session without name clashes.</p>
</li>
</ul>
<pre><code class="language-julia">Module MyScriptusing Package1
using PackageNfunction main&#40;; kwarg1&#61;1, kwarg2&#61;2&#41;
 # action here 
endend</code></pre>
<pre><code class="language-julia">&#36; julia
julia&gt; include&#40;&quot;MyScript.jl&quot;&#41;
julia&gt; MyScript.main&#40;kwarg1&#61;5&#41;</code></pre>
<ul>
<li><p>Load code via <code>using</code>. Once you have mastered modules and ensure that the file name corresponds to the module name, you can  load code via <code>using</code>. In order to allow for this, you need to ensure to have the directory containg <code>MyScript.jl</code> &#40;e.g. the current directory <code>pwd&#40;&#41;</code>&#41; on the <a href="https://docs.julialang.org/en/v1/base/constants/#Base.LOAD_PATH"><code>LOAD_PATH</code></a>:</p>
</li>
</ul>
<pre><code class="language-julia">&#36; julia
julia&gt; push&#33;&#40;LOAD_PATH,pwd&#40;&#41;&#41;
julia&gt; using MyScript
julia&gt; MyScript.main&#40;kwarg1&#61;5&#41;</code></pre>
<h2 id="use_revisejl_to_reload_modified_code">Use Revise.jl to reload modified code</h2>
<p>In the previous examples, re-loading the code after modifications required to re-run the include statement. The package <a href="https://github.com/timholy/Revise.jl">Revise.jl</a> exports a function <code>includet</code> which triggers automatic recompilation  if the source code of the script file or of packages used therein has been modified.</p>
<p>In order to set this up, place the following into the Julia startup file <code>.julia/config/startup.jl</code> in your home directory:</p>
<pre><code class="language-julia">using Revise</code></pre>
<p>You would then run:</p>
<pre><code class="language-julia">&#36; julia -i
julia&gt; includet&#40;&quot;MyScript.jl&quot;&#41;
julia&gt; MyScript.main&#40;kwarg1&#61;5&#41;</code></pre>
<p>After having modified <code>MyScript.jl</code>, just another  invocation of <code>MyScript.main&#40;&#41;</code>  would see the changes. See also the corresponding hints in the <a href="https://docs.julialang.org/en/v1/manual/workflow-tips/#Revise-based-workflows">Julia documentation</a>.</p>
<p>Besides of tracking scripts loaded into the REPL via <code>includet</code>, <code>Revise.jl</code> </p>
<ul>
<li><p>tracks changes in modules and packages under development loaded into the script via <code>using</code> or <code>import</code>.</p>
</li>
<li><p>works in <a href="https://github.com/fonsp/Pluto.jl">Pluto notebooks</a></p>
</li>
</ul>
<h2 id="record_your_project_dependencies_in_reproducible_environments">Record your project dependencies in reproducible environments</h2>
<h3 id="global_environment">Global environment</h3>
<p>By default, packages added to the Julia installation are recorded in the default <em>global environment</em>:</p>
<pre><code class="language-julia">&#36; julia
julia&gt;&#93;
pkg&gt; add Package1</code></pre>
<p>This results in  corresponding entries in <code>.julia/environments/vx.y/Project.toml</code>  and <code>.julia/environments/vx.y/Manifest.toml</code>  &#40;where <code>x.y</code> stands for your installed Julia version&#41;. Sharing this global  environment between all your different projects is risky because of possible conflicts in package version requirements. In addition, relying on the global environment makes it hard to share your code with others, as you would have to find a way to communicate the names of the  packages &#40;with versions&#41; which they need to install to run your code in a reproducible way.</p>
<h3 id="local_environments">Local environments</h3>
<p><em>Local environments</em> provide a remedy.</p>
<p>Assume that an  <em>application</em> is Julia code residing in a given directory <code>MyApp</code>, uses one or several other Julia packages and is not intended to be invoked from other packages or applications. An environment is described by the two files in the <code>MyApp</code> directory: <code>Project.toml</code> and <code>Manifest.toml</code>. Set up an environment in  the project directory in the following way:</p>
<pre><code class="language-julia">&#36; cd MyApp
&#36; julia
&#36; pkg&gt; activate .
&#36; pkg&gt; add Package1
&#36; pkg&gt; add PackageN
&#36; exit&#40;&#41;</code></pre>
<p>After setting up the environment like this, you can  perform</p>
<pre><code class="language-julia">&#36; cd MyApp
&#36; julia --project&#61;.</code></pre>
<p>and work in the environment. All packages added  to Julia in this case are recorded in <code>MyApp</code> instead of <code>.julia/environments/vx.y/</code>. Packages in the global environment still will be visible to your project.</p>
<p>The <code>Project.toml</code> file lists the packages added to the environment. In addition, a <code>Manifest.toml</code> file appears which holds the information about the exact versions of all Julia packages used by the project. Both  should be checked into version control along with the source code. If you took care about adding all necessary dependencies to the local environment, after checking out your code, another project collaborator can easily install all dependencies via</p>
<pre><code class="language-julia">&#36; cd MyApp
&#36; julia --project&#61;.
&#36; pkg&gt; instantiate</code></pre>
<h3 id="shared_environments">Shared &#40;&quot;<code>@</code>&quot;&#41; Environments</h3>
<p>Since Julia 1.7 it is possible to easily work with different more or less global environments:</p>
<pre><code class="language-julia">&#36; julia --project&#61;@myenv</code></pre>
<p>calls Julia and activates the environment <code>.julia/environments/myenv</code></p>
<p>This is e.g. useful when working with Pluto. One would start Julia via</p>
<pre><code class="language-julia">&#36; julia --project&#61;@pluto</code></pre>
<p>Just note that by default, each Pluto notebook will activates it&#39;s own environment.</p>
<h3 id="further_info">Further info</h3>
<ul>
<li><p>See also the corresponding documentation on <a href="https://pkgdocs.julialang.org/v1/environments/">environments</a> and <a href="https://pkgdocs.julialang.org/v1/toml-files/"><code>Project.toml</code> and <code>Manifest.toml</code></a>.</p>
</li>
<li><p>Pluto notebooks have their own <a href="https://github.com/fonsp/Pluto.jl/wiki/&#37;F0&#37;9F&#37;8E&#37;81-Package-management">built-in package management</a> and by default     contain a <code>Project.toml</code> and a <code>Manifest.toml</code> file to ensure portability.</p>
</li>
<li><p>See <a href="https://jkrumbiegel.com/pages/2022-08-26-pkg-introduction/">this blogpost</a> by Julius Krumbiegel for another take on Julia environments.</p>
</li>
<li><p>See my <a href="https://www.wias-berlin.de/people/fuhrmann/AdSciComp-WS2223/week3/#reproducibility_infrastructure_of_the_julia_language">talk</a> on the reproducibility infrastructure of the Julia language</p>
</li>
<li><p><a href="https://modernjuliaworkflows.github.io/">Modern Julia Workflows</a> A series of blog post drafts on best practices for Julia development.</p>
</li>
</ul><hr size="5" noshade><p><strong>Update history</strong></p>
<ul>
<li><p>2023-10-17: Link to modern julia workflowa</p>
</li>
<li><p>2023-04-24: Smaller improvements</p>
</li>
<li><p>2022-11-06: <code>@</code> environments &#40;since Julia 1.7&#41; &#43; LOAD_PATH, link to my talk on Julia&#39;s reproducibility infrastructure</p>
</li>
<li><p>2022-09-01: Link to <a href="https://jkrumbiegel.com/pages/2022-08-26-pkg-introduction/">blogpost</a> by Julius Krumbiegel</p>
</li>
<li><p>2022-02-09: RSS</p>
</li>
<li><p>2021-11-15: Initial version</p>
</li>
</ul>
 ]]>
  </content:encoded>
    
  <pubDate>Wed, 09 Feb 2022 00:00:00 +0000</pubDate>  
  
  
  <atom:author>
    <atom:name>JÃ¼rgen Fuhrmann</atom:name>
  </atom:author>
        
</item>

<item>
  <title>
    <![CDATA[  Julia: Achieving Performance   ]]>
  </title>
  <link> https://j-fu.github.io/marginalia/julia/achieving-performance/index.html </link>
  <guid> https://j-fu.github.io/marginalia/julia/achieving-performance/index.html </guid>
  <description>
    <![CDATA[  Julia: Achieving Performance.  ]]>
  </description>  
  
  <content:encoded>
    <![CDATA[  <h1 id="julia_achieving_performance">Julia: Achieving Performance </h1>
<div class="franklin-toc"><ol><li>Other resources on this topic</li><li>&quot;Measure performance with @time and pay attention to memory allocations&quot;</li><li>&quot;REPL based workflow&quot;</li><li>&quot;Avoid untyped global variables&quot;</li><li>&quot;Pre-allocate outputs&quot;</li><li>&quot;Avoid changing the type of a variable&quot; </li><li>&quot;More dots: fuse vectorized operations&quot;</li><li>&quot;Be aware of when Julia avoids specializing&quot;</li><li>&quot;Performance annotations&quot;</li></ol></div>
<p>In  order  to  let  newcomers  to the  language  experience  the  real performance potential of Julia it  is important to raise the awareness for the corresponding &quot;tricks&quot; early on.</p>
<p>This text results from an effort  to improve the code performance of a piece  of experimental  research  code  which has  been  written by  a colleague new  to Julia. It   describes the steps  taken  to  get runtime down from 13s to 0.07s and allocations form 763.08 M allocations to 86.</p>
<h2 id="other_resources_on_this_topic">Other resources on this topic</h2>
<ul>
<li><p>It turned out that all necessary information is described on the <a href="https://docs.julialang.org/en/v1/manual/performance-tips/#man-performance-tips">Julia performance tips</a> page, this text should be understood as an additional explanation from a bit different angle and a bit more in layman&#39;s terms.  The corresponding links to the documentation sections are provided.</p>
</li>
<li><p>Also, the <a href="https://www.stochasticlifestyle.com/7-julia-gotchas-handle/">7 Julia Gotchas</a> still are worth to read in this context.</p>
</li>
<li><p>UPDATE </p>
<ul>
<li><p>2021-12-01: Philippe MainÃ§on: <a href="https://blog.sintef.com/industry-en/writing-type-stable-julia-code/">Writing type-stable Julia code</a></p>
</li>
<li><p>2022-09-09: Jacob Nybo Nissen: <a href="https://biojulia.net/post/hardware/">What scientists must know about hardware to write fast code</a></p>
</li>
<li><p>2022-09-09: <a href="https://j-fu.github.io/marginalia/julia/unionize">Unionize your collections</a></p>
</li>
</ul>
</li>
</ul>
<h2 id="measure_performance_with_time_and_pay_attention_to_memory_allocations">&quot;Measure performance with @time and pay attention to memory allocations&quot;</h2>
<p><a href="https://docs.julialang.org/en/v1/manual/performance-tips/#Measure-performance-with-&#91;@time&#93;&#40;@ref&#41;-and-pay-attention-to-memory-allocation">Julia docs ðŸ”—</a></p>
<p>One allocation can use the time of several hundred floating point multiplications. </p>
<p>In order to understand the role of allocations ist is useful to  understand the concept of <a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html#the-stack-and-the-heap">stack and heap</a>, which is fundamental for any modern computer language &#40;as e.g. for Rust in the previous link&#41;.</p>
<p>An allocation reserves memory from the memory pool of the operating system &#40;&quot;heap&quot;&#41; and is expensive  as the  interaction  with the  operating  system  kernel needs certain amount of bookkeeping. Fundamentally, an allocation happens in  any language when  creating an object of a priori unknown size, e.g. an  array of length unknown at compile time. Objects with a priori known size, as e.g. structs  can be placed on top of a piece of memory pre-allocated during program start called &quot;stack&quot;, with almost no bookkeeping as no allocation from the system is necessary.</p>
<p>In Julia, the  <a href="https://docs.julialang.org/en/v1/base/base/#Base.@time"><code>@time</code></a> macro can be used to find allocations. Besides the execution time it prints  the number of allocations happening when running  the measured expression. There is also the possibility to run the code with  <a href="https://docs.julialang.org/en/v1/manual/command-line-options/#command-line-options"><code>julia --track-allocation</code></a>.</p>
<p>The idea is then &quot;hunt&quot; allocations by placing temporary @time statements in critical places of the code. In particular, removing allocations from &quot;hot loops&quot; with will pay off. </p>
<h2 id="repl_based_workflow">&quot;REPL based workflow&quot;</h2>
<p><a href="https://docs.julialang.org/en/v1/manual/workflow-tips/#REPL-based-workflow">Julia docs ðŸ”—</a> </p>
<p>During code development it is  helpful never to leave the Julia command line and to include the code after each change using the <code>include</code> statement. This approach avoids Just-in-time &#40;JIT&#41; recompilation which is peformed at startup time.</p>
<p>For more intense projects it is worth to use <a href="https://github.com/timholy/Revise.jl">Revise.jl</a> for automatic handling of code updates instead of calling <code>include</code> again and again.</p>
<p>Also it may be worth to have a look at the <a href="https://www.julia-vscode.org/">Visual Studio Code</a> editing environment for working with Julia.</p>
<h2 id="avoid_untyped_global_variables">&quot;Avoid untyped global variables&quot;</h2>
<p><a href="https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-untyped-global-variables">Julia docs ðŸ”—</a></p>
<p>Avoid to work with global variables. E.g. instead of</p>
<pre><code class="language-julia">a&#61;10 
b&#61;11function important&#40;x&#41;
   x&#61;5*a&#43;b
end@btime important&#40;10&#41;</code></pre>
<pre><code class="plaintext code-output">ArgumentError: Package BenchmarkTools not found in current path:
- Run `import Pkg; Pkg.add("BenchmarkTools")` to install the BenchmarkTools package.</code></pre>
<p>write</p>
<pre><code class="language-julia">a&#61;10
b&#61;11function important&#40;x,a,b&#41;
     x&#61;5*a&#43;b
end@btime important&#40;10,a,b&#41;</code></pre>
<pre><code class="plaintext code-output">LoadError: UndefVarError: @btime not defined
in expression starting at none:2
</code></pre>
<p>A more profound approach which would keep parameter lists  short may be the creation of a context <code>struct</code> which collects the parameters.</p>
<p>Alternatively, wrap the global context into a function </p>
<pre><code class="language-julia">function run&#40;&#41;
  a::Int&#61;10
  b::Int&#61;11  function important&#40;x&#41;
     x&#61;5*a&#43;b
  end
@btime important&#40;10&#41;
end
run&#40;&#41;</code></pre>
<pre><code class="plaintext code-output">LoadError: UndefVarError: @btime not defined
in expression starting at none:8
</code></pre>
<p>and ensure that <a href="https://docs.julialang.org/en/v1/manual/performance-tips/#man-performance-captured"><code>a</code> and <code>b</code> never change type</a> by <a href="https://docs.julialang.org/en/v1/manual/types/#Type-Declarations">type-annotating</a> them &#40;which is not possible for global variables in Julia versions &lt;1.8&#41;.</p>
<h5 id="rationale">Rationale:</h5>
<p>Julia assumes that a global variable can change its type anytime, so it needs to be wrapped  into a container &#40;&quot;boxing&quot;&#41; labeled with its current type. Handling these is expensive and manifests itself in additional allocations. Type changes of captured variables would have similar implications. In fact, this is very similar to the way e.g. python works with <em>any</em> variable.</p>
<h2 id="pre-allocate_outputs">&quot;Pre-allocate outputs&quot;</h2>
<p><a href="https://docs.julialang.org/en/v1/manual/performance-tips/#Pre-allocating-outputs">Julia docs ðŸ”—</a></p>
<p>Pre-allocate memory e.g. for arrays needed in inner loops. In the case where array sizes are unknown a priori,  replace expressions like <code>F&#61;&#91;something&#40;i&#41; for i&#61;1:N&#93;</code>  by </p>
<pre><code class="language-julia">function Fnum&#40;F&#41;
  ...
  if length&#40;F&#41;&lt;N
    resize&#33;&#40;F,N&#41;
  end
  for i&#61;1:N 
     F&#91;i&#93;&#61;something&#40;i&#41;
  end
  ...  
end</code></pre>
<p>where <code>F</code> is initialized e.g. via <code>F&#61;zeros&#40;0&#41;</code> is created once and passed to <code>FNum</code>. </p>
<h5 id="rationale__2">Rationale:</h5>
<p>An expression like <code>F&#61;&#91;...&#93;</code> creates an array and allocates memory for it. If this happens for a temporay variable used in a function called many times, this becomes a massive performance hit. Therefore, it is better  to pre-allocate this   memory, pass it to the inner loop function and to  increase it on necessity &#40;leading only to few allocations if the hitherto length was too short&#41;.</p>
<h2 id="avoid_changing_the_type_of_a_variable">&quot;Avoid changing the type of a variable&quot; </h2>
<p><a href="https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-changing-the-type-of-a-variable">Julia docs ðŸ”—</a></p>
<p>Replace <code>x&#61;0</code>, <code>x&#61;1</code>, etc. by <code>x&#61;0.0</code>, <code>x&#61;1.0</code> etc when it comes to declarations of variables later used as floating point values. </p>
<p>Another alternative is to <a href="https://docs.julialang.org/en/v1/manual/types/#Type-Declarations">type-annotate</a> variables when declaring them the first time: <code>x::FLoat64&#61;1</code>.</p>
<h5 id="rationale__3">Rationale:</h5>
<p>Setting <code>x&#61;1</code>, and writing  later <code>x&#61;2.0</code> changes the type of <code>x</code> and creates a <a href="https://docs.julialang.org/en/v1/manual/faq/#man-type-stability">type instability</a> with very much the same consequences as described above with respect to global variables. The <a href="https://docs.julialang.org/en/v1/manual/performance-tips/#man-code-warntype"><code>@code_warntype</code></a> macro can help to find corresponding situations.</p>
<h2 id="more_dots_fuse_vectorized_operations">&quot;More dots: fuse vectorized operations&quot;</h2>
<p><a href="https://docs.julialang.org/en/v1/manual/performance-tips/#More-dots:-Fuse-vectorized-operations">Julia docs ðŸ”—</a></p>
<p>Replace vector expressions like </p>
<pre><code class="language-julia">u&#61;v-w</code></pre>
<p>by either </p>
<pre><code class="language-julia">u.&#61; v.-w</code></pre>
<p>or the equivalent </p>
<pre><code class="language-julia">@. u&#61;v-w</code></pre>
<h5 id="rationale__4">Rationale:</h5>
<p>Vector expressions without dot &quot;.&quot; result in handling each elementary expression in its own loop over vector length and creating  intermediate values which need to be allocated.</p>
<p>The dot tells Julia to <em>fuse</em> these loops, that means the Julia compiler creates exactly one loop which applies the operations component-wise instead of creating code for each operation apart. This removes multiple loop bookkeeping overheads and avoids allocation of memory for intermediate expressions.</p>
<p>Connected to his hint is the fact that unlike with python/numpy, in Julia there is no need to &quot;vectorize&quot; code for performance. Writing your own loops or writing fused vector expressions is sufficient to get full performance with Julia. </p>
<h2 id="be_aware_of_when_julia_avoids_specializing">&quot;Be aware of when Julia avoids specializing&quot;</h2>
<p><a href="https://docs.julialang.org/en/v1/manual/performance-tips/#Be-aware-of-when-Julia-avoids-specializing">Julia docs ðŸ”—</a></p>
<p>Moving functions parametrizing the code from global variables to function parameters creates  a new source of allocations. This can be  removed by type-annotating the newly introduced function parameters.</p>
<p>E.g. for <code>func</code> being a function  parameter of <code>g</code>, replace</p>
<pre><code class="language-julia">function  g&#40;func, a,b,c&#41;
...
end</code></pre>
<p>by</p>
<pre><code class="language-julia">function   g&#40;func::T, a, b,c&#41; where &#123;T&#125;
...
end</code></pre>
<h4 id="rationale__5">Rationale:</h4>
<p>Usually, if Julia is aware of the types of parameters passed to a function, it  creates specialized code for each combination of type signatures. E.g.  with a definition <code>f&#40;x&#41;&#61;x*x</code> Julia is triggered to create  code for floating point numbers when calling <code>f&#40;2.0&#41;</code> and  for rational numbers when calling <code>f&#40;2//1&#41;</code>.  This behavior is called <em>specialization</em>.</p>
<p>There are exceptions to this rule. One exception are function parameters. Julia by default does not specialize on function parameter types &#40;in Julia, each function has its own type&#41;, resulting in an allocation when calling the first version of <code>g&#40;func,a,b,c&#41;</code>, even when the body of <code>g</code> is &quot;allocation free&quot;.</p>
<p>Type-annotating <code>func</code> in the parameter list of <code>g</code> with a <a href="https://docs.julialang.org/en/v1/base/base/#where">type parameter</a>  triggers Julia to create specialized code for each function passed.</p>
<h2 id="performance_annotations">&quot;Performance annotations&quot;</h2>
<p><a href="https://docs.julialang.org/en/v1/manual/performance-tips/#man-performance-annotations">Julia docs ðŸ”—</a></p>
<p>Annotate  inner loops with <code>@fastmath @inbounds</code> to remove bounds checking and some speed constraints inherent to pure  IEEE floating point arithmetic.</p>
<p>
<hr size="5" noshade>
 <strong>Update history</strong></p>
<ul>
<li><p>2023-04-24: Smaller improvements</p>
</li>
<li><p>2022-09-09: Updates on other resources</p>
</li>
<li><p>2022-02-09: RSS</p>
</li>
<li><p>2021-11-15: Initial version</p>
</li>
</ul>
 ]]>
  </content:encoded>
    
  <pubDate>Wed, 09 Feb 2022 00:00:00 +0000</pubDate>  
  
  
  <atom:author>
    <atom:name>JÃ¼rgen Fuhrmann</atom:name>
  </atom:author>
        
</item>
</channel></rss>