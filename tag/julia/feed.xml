<?xml version="1.0" encoding="UTF-8"?>

<rss version="2.0"
  xmlns:content="http://purl.org/rss/1.0/modules/content/"
  xmlns:dc="http://purl.org/dc/elements/1.1/"
  xmlns:media="http://search.yahoo.com/mrss/"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:georss="http://www.georss.org/georss">

  <channel>
    <title>
      <![CDATA[  Marginalia  ]]>
    </title>
    <link> https://j-fu.github.io/marginalia/ </link>
    <description>
      <![CDATA[  Remarks on computing &amp; stuff  ]]>
    </description>
    <atom:link
      href="https://j-fu.github.io/marginalia/feed.xml"
      rel="self"
      type="application/rss+xml" />


<item>
  <title>
    <![CDATA[  Julia: Project Workflow Howto  ]]>
  </title>
  <link> https://j-fu.github.io/marginalia/julia/project-howto/index.html </link>
  <guid> https://j-fu.github.io/marginalia/julia/project-howto/index.html </guid>
  <description>
    <![CDATA[  Julia: Project Workflow.  ]]>
  </description>  
  
  <content:encoded>
    <![CDATA[  <h1 id="julia_project_workflow_howto">Julia: Project Workflow Howto</h1>
<p>This post complements the <a href="https://j-fu.github.io/marginalia/julia/project-workflow">project workflow recommendations</a>. It tries to explain in a more introductory and rather assertive way how to work  on collaborative projects &#40;not packages&#41; in Julia which follow the convention described in the <a href="https://j-fu.github.io/marginalia/julia/project-workflow">project workflow recommendations</a>.</p>
<p>The most important feature of the approach described consists in the idea that each project has its own package environment, as described in   <a href="https://j-fu.github.io/marginalia/julia/basic-workflow/#record_project_dependencies_in_reproducible_environments">&quot;Basic Workflow&quot;</a>. This allows to prevent package compatibility clashes between different projects. <div class="franklin-toc"><ol><li>The project files</li><li>Installation and updating of dependent packages</li><li>Running code<ol><li>Scripts</li><li>Notebooks</li></ol></li></ol></div> </p>
<h2 id="the_project_files">The project files</h2>
<p>After checking out the project the first time, you will see it populated with a number of files and subdirectories.</p>
<p>The essential role of files a typical Julia project file tree is as follows:</p>
<ul>
<li><p><code>Project.toml</code>: This file describes the project on a high level, including the packages it depends on and their compatibility constraints as described in <a href="https://j-fu.github.io/marginalia/julia/basic-workflow/#record_your_project_dependencies_in_reproducible_environments">&quot;Basic Workflow&quot;</a>.</p>
</li>
<li><p><code>LICENSE</code>: License of the project.</p>
</li>
<li><p><code>README.md</code>: A general description of the project</p>
</li>
<li><p><code>src</code>: Subdirectory for project specific source code shared between scripts and notebooks of the project</p>
</li>
<li><p><code>test</code>: Unit tests for the project code in <code>src</code>. Could include something from <code>scripts</code>, <code>notebooks</code>.</p>
</li>
<li><p><code>packages</code>: Subdirectory containing packages developed locally in this project. At some stage these could be turned into separate Julia packages.</p>
</li>
<li><p><code>scripts</code>: Julia scripts for creating project results. </p>
</li>
<li><p><code>notebooks</code>: Interactive notebooks</p>
</li>
<li><p><code>docs</code>:  Sources for the documentation created with <code>Documenter.jl</code></p>
</li>
</ul>
<h2 id="installation_and_updating_of_dependent_packages">Installation and updating of dependent packages</h2>
<p>After checking out the code with git, at first it is necessary to instantiate the project environment. Go to the project root directory and invoke</p>
<pre><code class="language-julia">&#36; julia --project&#61;.
julia&gt; using Pkg
julia&gt; Pkg.resolve&#40;&#41;</code></pre>
<p>This uses the Julia package manager to automatically download and precompile all Julia packages listed as dependencies in <code>Project.toml</code>.  It also will create a <code>Manifest.toml</code> file which records recursively all dependencies with their exact versions.</p>
<p>Likewise, after updating some code from the git repository, it is possible to update the project environment:</p>
<pre><code class="language-julia">&#36; julia --project&#61;.
julia&gt; using Pkg
julia&gt; Pkg.update&#40;&#41;</code></pre>
<h2 id="running_code">Running code</h2>
<p>In order to ensure the activation of the project evironment described in <code>Project.toml</code>, all scripts and all notebooks activate the project environment at their respective start. Typically, this looks like</p>
<pre><code class="language-julia">Pkg.activate&#40;joinpath&#40;@__DIR__, &quot;...&quot;&#41;&#41;</code></pre>
<h3 id="scripts">Scripts</h3>
<p>To run script <code>scripts/script1.jl</code>, perform from the project root:</p>
<pre><code class="language-julia">&#36; julia --project&#61;.
julia&gt; using Revise
julia&gt; includet&#40;&quot;scripts/demo-script.jl&quot;&#41;</code></pre>
<p>See <a href="https://j-fu.github.io/marginalia/julia/basic-workflow/#use_revisejl_to_reload_modified_code">here</a> for an explanation of <code>Revise</code>.</p>
<p>With some precompilation hiatus, it is also possible to just run</p>
<pre><code class="language-julia">julia scripts/script1.jl</code></pre>
<h3 id="notebooks">Notebooks</h3>
<p>To run the Pluto notebook <code>notebooks/demo-notebook.jl</code>, <a href="https://plutojl.org">install Pluto</a> in your global environment and perform</p>
<pre><code class="language-julia">&#36; julia 
julia&gt; using Pluto
julia&gt; Pluto.run&#40;notebook&#61;&quot;notebooks/notebook1.jl&quot;&#41;</code></pre>
<p>
<hr size="5" noshade>
 <strong>Update history</strong></p>
<ul>
<li><p>2025-22-01: Updated some wording</p>
</li>
<li><p>2024-10-02: Initial version </p>
</li>
</ul>
 ]]>
  </content:encoded>
    
  <pubDate>Wed, 02 Oct 2024 00:00:00 +0000</pubDate>  
  
  
  <atom:author>
    <atom:name>Jürgen Fuhrmann</atom:name>
  </atom:author>
        
</item>

<item>
  <title>
    <![CDATA[    ]]>
  </title>
  <link> https://j-fu.github.io/marginalia/julia/scalingtest/index.html </link>
  <guid> https://j-fu.github.io/marginalia/julia/scalingtest/index.html </guid>
  <description>
    <![CDATA[  Sparse matrix solver scaling  ]]>
  </description>  
  
  <content:encoded>
    <![CDATA[  <h1 id="13633231208144796923"></h1><iframe style="height:9800px" width="100%" frameborder="0" src="https://j-fu.github.io/marginalia/assets/scalingtest2.html"> </iframe> ]]>
  </content:encoded>
    
  <pubDate>Thu, 13 Jul 2023 00:00:00 +0000</pubDate>  
  
  
  <atom:author>
    <atom:name>Jürgen Fuhrmann</atom:name>
  </atom:author>
        
</item>

<item>
  <title>
    <![CDATA[  Julia: Package Workflow  ]]>
  </title>
  <link> https://j-fu.github.io/marginalia/julia/package-workflow/index.html </link>
  <guid> https://j-fu.github.io/marginalia/julia/package-workflow/index.html </guid>
  <description>
    <![CDATA[  Julia: Package Workflow.  ]]>
  </description>  
  
  <content:encoded>
    <![CDATA[  <h1 id="julia_package_workflow">Julia: Package Workflow</h1>
<p>&#40;Draft, work in progress&#41;</p>
<div class="franklin-toc"><ol><li>Resources</li><li>Starting a package<ol><li>Where do packages under development reside ?</li><li>Starting a package repository</li></ol></li><li>Tests</li><li>Documentation<ol><li>Generation using <a href="https://documenter.juliadocs.org/stable/">Documenter.jl</a></li><li>Local preview using <a href="https://github.com/JuliaDocs/LiveServer.jl">LiveServer.jl</a></li></ol></li><li>Running things on github</li><li>Providing packages to others<ol><li>Using a package under development</li><li>Registration of a new package or a new version in a local registry</li><li>Using the General registry</li></ol></li></ol></div>
<h2 id="resources">Resources</h2>
<ul>
<li><p>Some other useful introductions to package authoring</p>
<ul>
<li><p>G. Dalle, J. Smit, A. Hill: <a href="https://modernjuliaworkflows.github.io/">Modern Julia Workflows</a> &#40;2024-09&#41;</p>
</li>
<li><p>Jaan Tollander de Balsch:  <a href="https://jaantollander.com/post/how-to-create-software-packages-with-julia-language/">How to Create Software Packages with Julia Language</a> &#40;2021-05&#41;</p>
</li>
<li><p>Sören Dobberschütz: <a href="https://sdobber.github.io/juliapackage/">Tips and tricks to register your first Julia package</a> &#40;2021-10&#41;</p>
</li>
<li><p>Kim Fung: <a href="https://medium.com/analytics-vidhya/an-introduction-to-continuous-integration-github-actions-for-julia-1a5a1a6e64d6">An Introduction to Continuous Integration &amp; GitHub Actions for Julia</a> &#40;2020-01&#41;</p>
</li>
<li><p>Christopher Rackauckas: <a href="https://www.stochasticlifestyle.com/developing-julia-packages/">Developing Julia packages &#40;video&#41;</a> &#40;2019-10&#41;</p>
</li>
</ul>
</li>
<li><p><a href="https://pkgdocs.julialang.org/v1/glossary/#Glossary">Package manager glossary</a>. According to this, here, we assume that a  <em>package</em> is Julia code which is supposed to be used by other projects, applications or packages.</p>
</li>
</ul>
<h2 id="starting_a_package">Starting a package</h2>
<h3 id="where_do_packages_under_development_reside">Where do packages under development reside ?</h3>
<p>When developing Julia packages it is advisable to set the environment variable <a href="https://pkgdocs.julialang.org/v1/api/#Pkg.develop"><code>JULIA_PKG_DEVDIR</code></a> to a path convenient for you. By default &#40;if <a href="https://docs.julialang.org/en/v1/manual/environment-variables/#JULIA_DEPOT_PATH"><code>JULIA_DEPOT_PATH</code></a> was not changed&#41; it is <code>.julia/dev</code>. Julia packages checked out for development via <code>Pkg.develop&#40;&#41;</code>  will reside there, and it is convenient to have all packages under development in this path.</p>
<h3 id="starting_a_package_repository">Starting a package repository</h3>
<p>The <a href="https://pkgdocs.julialang.org/v1/creating-packages/">creating packges</a> chapter of the package manager documentation explains how to create a package with a minimal functional structure. Enabling important aspects of package workflow like  continuous integration, documentation generation or git integration would involve the addition of all of this tooling by hand.</p>
<p>The package <a href="https://github.com/JuliaCI/PkgTemplates.jl">PkgTemplates.jl</a> provides standard templates for creating Julia packages:</p>
<pre><code class="language-julia">&#36; cd &#36;JULIA_PKG_DEVDIR
&#36; julia
julia&gt; using PkgTemplates
julia&gt; t &#61; Template&#40;;
    user&#61;&quot;UserName&quot;,
    dir&#61;&quot;.&quot;,
    julia&#61;v&quot;1.10&quot;,
    plugins&#61;&#91;
    Git&#40;; manifest&#61;false, ssh&#61;true&#41;,
    GitHubActions&#40;&#41;,
    Codecov&#40;&#41;,
    Documenter&#123;GitHubActions&#125;&#40;&#41;,
    &#93;,
    &#41;julia&gt; t&#40;&quot;MyPkg&quot;&#41;</code></pre>
<p>This creates a standard Julia package structure enhanced with tooling for CI, documentation, git etc., which is ready to be pushed to a corresponding github repository:</p>
<pre><code class="language-julia">MyPkg
├── .git
│  ...
├── .github
│  ├── dependabot.yml
│  └── workflows
│     ├── CI.yml
│     ├── CompatHelper.yml
│     └── TagBot.yml
├── .gitignore
├── docs
│  ├── make.jl
│  ├── Manifest.toml
│  ├── Project.toml
│  └── src
│     └── index.md
├── LICENSE
├── Manifest.toml
├── Project.toml
├── README.md
├── src
│  └── MyPkg.jl
└── test
   └── runtests.jl</code></pre>
<ul>
<li><p><a href="https://pkgdocs.julialang.org/v1/toml-files/#Project.toml"><code>Project.toml</code></a>: description of dependencies. This also provides the package with its own environment during development. It contains the universally unique identifier &#40;UUID&#41; used to identify the package and its name, author and version number.</p>
</li>
<li><p><code>README.md</code>: Short information about the package. This will occur on the landing page  of the github repository</p>
</li>
<li><p><code>LICENSE</code>: License information. Should be one of the <a href="https://opensource.org/licenses">OSI approved</a> open source license if the package shall be registered with the Julia General Registry</p>
</li>
<li><p><code>src</code>: subdirectory containing code</p>
<ul>
<li><p><code>src/MyPkg.jl</code>: Julia source file which must contain a module <code>NewPackageName</code> where all package code resides. It may include further source code files.</p>
</li>
</ul>
</li>
<li><p><code>test</code>: subdirectory containing test code</p>
<ul>
<li><p><code>test/runtests.jl</code>: script for running tests</p>
</li>
<li><p><code>test/Project.toml</code>: &#40;optional&#41; environment file containing test only dependencies</p>
</li>
</ul>
</li>
<li><p><code>docs</code>: subdirectory containing documentation</p>
<ul>
<li><p><code>docs/make.jl</code>: script for building documentation based on Documenter.jl</p>
</li>
<li><p><code>docs/Project.toml</code>: environment file containing dependencies for documentation</p>
</li>
</ul>
</li>
<li><p><code>.github</code> Configuration files for Continuous Integration</p>
<ul>
<li><p><a href="https://discourse.julialang.org/t/psa-use-dependabot-to-update-github-actions-automatically/96001/2?u&#61;j-fu"><code>.github/dependabot.yml</code></a>: github action which triggers a pull request if a workflow file has a new version</p>
</li>
<li><p><code>.github/workflows/CI.yml</code> Control file for running continuous integration tests on github</p>
</li>
<li><p><code>.github/workflows/CompatHelper.yml</code>  github action which triggers a pull request if a package dependency has a new breaking version</p>
</li>
<li><p><code>.github/workflows/TagBot.yml</code>  github action which automatically creates git tags for newly registered versions of <code>MyPkg</code>.</p>
</li>
<li><p>A  <a href="https://pkgdocs.julialang.org/v1/toml-files/#Manifest.toml"><code>Manifest.toml</code></a> file is created as soon as the package environment is instantiated. It contains the full metadata of  all package dependencies. This file <em>should not be tracked by git</em>. Instead, the <code>Project.toml</code> shall contain a <code>&#91;compat&#93;</code> section which inform the package resolver about the compatibility with different versions of dependencies.</p>
</li>
</ul>
</li>
</ul>
<h2 id="tests">Tests</h2>
<p>See also the <a href="https://pkgdocs.julialang.org/v1/creating-packages/#Adding-tests-to-the-package">Pkg documentation</a>.</p>
<p>The files in <code>test</code> provide the environment and the code to run tests of the functions implemented in the package. While it is hard to have 100&#37; test coverage of the package functionality, one should strive to achieve this goal. Besides of the obvious reasons of reproducibility,  peer pressure etc., sufficient test coverage helps to keep a package author sane. Imagine the need to change something in the  package three years after the last serious work on it...</p>
<p>It is quite possible that tests have more dependencies than the package itself. Therefore Julia packages can have their own test environment in <code>test/Project.toml</code>. Alternatively, the test dependencies can be listed in an &quot;&#91;extras&#93;&quot; section of <code>MyPkg/Project.toml</code>. The <code>test/runtests.jl</code> file contains the code for the tests. All code called from the <a href="https://docs.julialang.org/en/v1/stdlib/Test/#Test.@test"><code>@test</code></a> macro is part of the test coverage. A simple file <code>runtests.jl</code> contains e.g.:</p>
<pre><code class="language-julia">using Test@test 1&#43;1 &#61;&#61; 2</code></pre>
<p>Tests code can be called in different ways. In the package root environment:</p>
<pre><code class="language-julia">julia&gt; Pkg.test&#40;&#41;</code></pre>
<p>or from the <code>Pkg</code> prompt:</p>
<pre><code class="language-julia">&#93; test</code></pre>
<p>The seame test can be invoked also in any environment with the package added:</p>
<pre><code class="language-julia">julia&gt; Pkg.test&#40;&quot;MyPkg&quot;&#41;</code></pre>
<p>or</p>
<pre><code class="language-julia">&#93; test MyPkg</code></pre>
<h2 id="documentation">Documentation</h2>
<h3 id="generation_using_a_hrefhttpsdocumenterjuliadocsorgstabledocumenterjl">Generation using <a href="https://documenter.juliadocs.org/stable/">Documenter.jl</a></h3>
<p>Documenter collects the docstrings of functions of a package and builds a documentation website. If <code>MyPkg</code> contains code with docstrings like</p>
<pre><code class="language-julia">&quot;&quot;&quot;
    mult&#40;x,y&#41;Calculates the product of &#96;x&#96; and &#96;y&#96;
&quot;&quot;&quot;
function mult&#40;x,y&#41;
    return x*y
end</code></pre>
<p>In a documentation markdown file this can be referred to in a &quot;<a href="https://documenter.juliadocs.org/stable/man/syntax/#@docs-block">@docs block</a>&quot;.</p>
<p>Documentation is built using the script <code>docs/make.jl</code> which needs to be started in the environmet defined in <code>docs</code>:</p>
<pre><code class="language-julia">&#36; julia --project&#61;docs
julia&gt; include&#40;&quot;docs/make.jl&quot;&#41;</code></pre>
<h3 id="local_preview_using_a_hrefhttpsgithubcomjuliadocsliveserverjlliveserverjl">Local preview using <a href="https://github.com/JuliaDocs/LiveServer.jl">LiveServer.jl</a></h3>
<p>By default, locally built documentation is created in the <code>docs/build</code> subdirectory. Preview can be performed using a local webserver pointing to this directory.</p>
<p><a href="https://github.com/JuliaDocs/LiveServer.jl">LiveServer.jl</a> provides one:</p>
<pre><code class="language-julia">julia&gt; using LiveServer
julia&gt; serve&#40;dir&#61;&quot;docs/build&quot;, port&#61;8001&#41;</code></pre>
<p>This starts a web browser pointing to <code>http://localhost:8100</code>, allowing to navigate documentations locally.</p>
<h2 id="running_things_on_github">Running things on github</h2>
<p>For public repositories, github provides unlimited access to <a href="https://docs.github.com/en/actions/writing-workflows/quickstart">Github actions</a>. This means that the scripts under <code>.github/workflows</code> are active and triggered at the events described therein. Among others, the <code>CI.yml</code> triggers running of tests and documentation at every push to the main branch.</p>
<p>The script tries to deploy the documentation to a separate branch which publishes the documentation under <code>https://github.io/UserName/MyPkg</code>. For this purpose, github actions need to authenticate theselves with the repository. For this purpose, a <code>DOCUMENTER_KEY</code> ssh key needs to be stored in the repository. The setup is described in the <a href="https://documenter.juliadocs.org/stable/lib/public/#DocumenterTools.genkeys">Documenter.jl documentation</a>.</p>
<p>Alternatively, this can be done for <a href="https://discourse.julialang.org/t/julia-and-gitlab-self-hosted-a-state-of-the-art/86685">gitlab</a> as well.</p>
<h2 id="providing_packages_to_others">Providing packages to others</h2>
<h3 id="using_a_package_under_development">Using a package under development</h3>
<p>While the package is unregistered you can add it to the environment of a project:</p>
<pre><code class="language-julia">&#36; cd project_dir
&#36; julia --project&#61;@.
pkg&gt; add git_url</code></pre>
<p>In this case, the version in the git repository on the server is used via a shallow clone &#40;clone without versioning information&#41; created in <code>&#36;HOME/.julia/packages</code>. If you use</p>
<pre><code class="language-julia">pkg&gt; dev git_url</code></pre>
<p>instead, a full clone is created in <code>&#36;JULIA_PKG_DEVDIR</code> and used. If the corresponding subdirectory in <code>JULIA_PKG_DEVDIR</code> does not exist, it will be checked out from <code>git_url</code>. The same would happen with registered packages added by name.</p>
<h3 id="registration_of_a_new_package_or_a_new_version_in_a_local_registry">Registration of a new package or a new version in a local registry</h3>
<p>A registry is a git repository containing package information which allows to find the package source code given the package name. By default, julia packages are found in the General registry, wich is also installed by default. However, it is possible to have multiple registries, and to maintain your own registry.</p>
<p>The <a href="https://github.com/GunnarFarneback/LocalRegistry.jl">LocalRegistry.jl</a> allows for an easy workflow.</p>
<p>We assume to speak about <code>MyRegistry</code> as an example, but generally this is true for all registries. Assuming write access to the repository containing <code>MyRegistry</code>, the process is the following:</p>
<p>Registring a new version of MyPkg goes as simple as follows:</p>
<pre><code class="language-julia">MyPkg&#36; julia --project
julia&gt; using MyPkg
julia&gt; using LocalRegistry
julia&gt; LocalRegistry.register&#40;X,&quot;MyRegistry&quot;, push&#61;true&#41;</code></pre>
<p>After this, do not forget to create a tag in your repository marking the version <code>x.y.z</code> of the package:</p>
<pre><code class="language-julia">&#36; git tag vx.y.z</code></pre>
<p>If users want to access <code>MyPkg</code> via this registry, they first need to add the registry to their julia installation:</p>
<pre><code class="language-julia">julia&gt; Pkg.Registry.add&#40;&quot;https://github.com/UserName/MyRegistry&quot;&#41;</code></pre>
<p>After that, they can add the package as usual:</p>
<pre><code class="language-julia">julia&gt; Pkg.add&#40;&quot;MyPackage&quot;&#41;</code></pre>
<h3 id="using_the_general_registry">Using the General registry</h3>
<p>Registering and updating packages in the general registry is automatically handeled by the <a href="https://github.com/JuliaRegistries/Registrator.jl">JuliaRegistrator</a> github app.</p>
<p>It assumes compliance to a number of <a href="https://juliaregistries.github.io/RegistryCI.jl/stable/guidelines/">heuristic rules</a> concerning package names, Project.toml content etc.</p>
<p>If these are followed, just comment the most recent commit of your package with</p>
<pre><code class="language-julia">@JuliaRegistrator register</code></pre>
<p>and the process starts. JuliaRegistrator checks compliance to the rules, and finally merges the updated information into the General registry</p>
<ul>
<li><p>after 3 days for a new package</p>
</li>
<li><p>after \(\approx\) 20 min for a new version</p>
</li>
</ul><div class="img-small">
<img src="https://raw.githubusercontent.com/JuliaRegistries/Registrator.jl/master/graphics/logo.png">
</div><p>It needs to be installed as a github app in for the package repository.</p>
<p>
<hr size="5" noshade>
 <strong>Update history</strong></p>
<ul>
<li><p>2024-10-23: Fundamental update</p>
</li>
<li><p>2023-04-24: Draft updated &#43; made public</p>
</li>
<li><p>2022-12-06: First draft</p>
</li>
</ul>
 ]]>
  </content:encoded>
    
  <pubDate>Mon, 24 Apr 2023 00:00:00 +0000</pubDate>  
  
  
  <atom:author>
    <atom:name>Jürgen Fuhrmann</atom:name>
  </atom:author>
        
</item>

<item>
  <title>
    <![CDATA[  Julia: Introductory material  ]]>
  </title>
  <link> https://j-fu.github.io/marginalia/julia/intro-material/index.html </link>
  <guid> https://j-fu.github.io/marginalia/julia/intro-material/index.html </guid>
  <description>
    <![CDATA[  Julia: Introductory material.  ]]>
  </description>  
  
  <content:encoded>
    <![CDATA[  <h1 id="julia_introductory_material">Julia: Introductory material</h1>
<p>This is a collection of online references pointing at introductory material for the Julia language.If you look for further online resources, please ensure that they are for Julia 1.0 and newer. This is best achieved by looking for material not older than 2019.</p>
<div class="franklin-toc"><ol><li>Installation</li><li>Learning<ol><li>Resources curated by the Julia development team.</li><li>More learning resources </li></ol></li><li>Introductory material from my TU Berlin courses  and other talks &#40;videos &#43; Pluto notebooks&#41;</li><li>Editing</li></ol></div>
<h2 id="installation">Installation</h2>
<p><a href="https://julialang.org/downloads/#install_julia">juliaup</a> provides the most flexible way to install Julia and to switch between versions. Alternatively, install the latest stable version via the Julia <a href="https://julialang.org/downloads/#current_stable_release">homepage</a>. Julia devs <a href="https://julialang.org/downloads/#please_do_not_use_the_version_of_julia_shipped_by_unix_package_managers">recommend not to use</a> the Julia versions provided from other sources &#40;like Homebrew, various Linux package managers&#41;. </p>
<h2 id="learning">Learning</h2>
<h3 id="resources_curated_by_the_julia_development_team">Resources curated by the Julia development team.</h3>
<ul>
<li><p><a href="https://docs.julialang.org/en/v1/">Julia documentation</a></p>
<ul>
<li><p><a href="https://docs.julialang.org/en/v1/manual/getting-started/">Getting started</a></p>
</li>
<li><p>Noteworthy differences from <a href="https://docs.julialang.org/en/v1/manual/noteworthy-differences/#Noteworthy-differences-from-MATLAB-1">Matlab</a>, <a href="https://docs.julialang.org/en/v1/manual/noteworthy-differences/#Noteworthy-differences-from-R-1">R</a>, <a href="https://docs.julialang.org/en/v1/manual/noteworthy-differences/?highlight&#61;matlab#Noteworthy-differences-from-Python-1">Python</a>, <a href="https://docs.julialang.org/en/v1/manual/noteworthy-differences/#Noteworthy-differences-from-C/C">C/C&#43;&#43;</a></p>
</li>
</ul>
</li>
<li><p><a href="https://julialang.org/learning/">Curated learning resources</a></p>
</li>
<li><p><a href="https://julialang.org/learning/books/">Books</a></p>
</li>
<li><p>Julia is evolving. New versions in the 1.x range introduce many important additions and non-breaking changes. Many important Julia packages require at least the current long term service &#40;LTS&#41; version 1.10. </p>
<ul>
<li><p>Julia version highlights: <a href="https://julialang.org/blog/2020/08/julia-1.5-highlights/">1.5</a>, <a href="https://julialang.org/blog/2021/03/julia-1.6-highlights/">1.6</a>, <a href="https://julialang.org/blog/2021/11/julia-1.7-highlights/">1.7</a>, <a href="https://julialang.org/blog/2022/08/julia-1.8-highlights/">1.8</a>, <a href="https://julialang.org/blog/2023/04/julia-1.9-highlights/">1.9</a>, <a href="https://julialang.org/blog/2023/12/julia-1.10-highlights/">1.10</a>, <a href="https://julialang.org/blog/2024/10/julia-1.11-highlights/">1.11</a></p>
</li>
<li><p><a href="https://towardsdatascience.com/why-julia-2-0-isnt-coming-anytime-soon-and-why-that-is-a-good-thing-641ae3d2a177">Why Julia 2.0 Isn’t Coming Anytime Soon</a></p>
</li>
</ul>
</li>
</ul>
<h3 id="more_learning_resources">More learning resources </h3>
<ul>
<li><p>The book <a href="https://web.stanford.edu/~boyd/vmls/">Introduction to Applied Linear Algebra – Vectors, Matrices, and Least Squares</a> by Stephen Boyd and Lieven Vandenberghe has a <a href="http://vmls-book.stanford.edu/vmls-julia-companion.pdf">Julia companion</a></p>
</li>
<li><p><a href="https://juliadocs.github.io/Julia-Cheat-Sheet/">Cheat Sheet</a></p>
</li>
<li><p><a href="https://cheatsheets.quantecon.org/">Matlab-Julia-Python cheat sheet</a></p>
</li>
<li><p><a href="https://julia.quantecon.org/index_toc.html">QuantEcon</a> tutorial with focus on economics and statistics</p>
</li>
<li><p><a href="https://www.youtube.com/c/juliafortalentedamateurs/videos">Julia for Talented Amateurs</a>: Collection of video tutorials for many different aspects of Julia</p>
</li>
<li><p><a href="https://en.wikibooks.org/wiki/Introducing_Julia">WikiBook</a></p>
</li>
</ul>
<h2 id="introductory_material_from_my_tu_berlin_courses_and_other_talks_videos_pluto_notebooks">Introductory material from my TU Berlin courses  and other talks &#40;videos &#43; Pluto notebooks&#41;</h2>
<ul>
<li><p><a href="https://www.wias-berlin.de/people/fuhrmann/teaching/">My teaching homepage</a>. Generally, the material from the first couple of weeks can serve as an introduction to Julia. Material is provided in form of Pluto notebooks &#40;versions rendered html and pdf are linked as well&#41;. While video recordings may have been &quot;recycled&quot; from previous years, the notebook Julia files linked are updated to the corresponding current stable Julia version at the moment of the start of the semester.</p>
</li>
<li><p><a href="https://av.tib.eu/media/57515">The Julia programming language - an overview</a>. Talk at <a href="https://www.wias-berlin.de/workshops/MMSDays22/">Leibniz MMS Days 2022</a>.</p>
</li>
</ul>
<h2 id="editing">Editing</h2>
<ul>
<li><p><a href="https://www.julia-vscode.org/docs/latest/gettingstarted/">Visual Studio Code extension</a></p>
</li>
<li><p><a href="https://plutojl.org">Pluto notebooks</a>;    How to install Julia and Pluto: <a href="https://www.youtube.com/watch?v&#61;OOjKEgbt8AI">MIT course video</a></p>
</li>
<li><p><a href="https://github.com/JuliaEditorSupport/julia-emacs">Emacs support</a></p>
</li>
<li><p><a href="https://zed.dev/docs/languages/julia">zed support</a></p>
</li>
</ul><hr size="5" noshade><p><strong>Update history</strong></p>
<ul>
<li><p>2025-01-21: Julia 1.11, update some links, streamline reference to my courses</p>
</li>
<li><p>2024-10-02: Julia 1.10, upvote juliaup</p>
</li>
<li><p>2023-10-17: Julia as a second language, semester info</p>
</li>
</ul>
 ]]>
  </content:encoded>
    
  <pubDate>Sun, 23 Apr 2023 00:00:00 +0000</pubDate>  
  
  
  <atom:author>
    <atom:name>Jürgen Fuhrmann</atom:name>
  </atom:author>
        
</item>

<item>
  <title>
    <![CDATA[    ]]>
  </title>
  <link> https://j-fu.github.io/marginalia/julia/sparsejac/index.html </link>
  <guid> https://j-fu.github.io/marginalia/julia/sparsejac/index.html </guid>
  <description>
    <![CDATA[  Calculating sparse jacobians  ]]>
  </description>  
  
  <content:encoded>
    <![CDATA[  <h1 id="13633231208144796923"></h1><iframe style="height:9800px" width="100%" frameborder="0" src="https://j-fu.github.io/marginalia/assets/sparsejac.html"> </iframe> ]]>
  </content:encoded>
    
  <pubDate>Sat, 22 Oct 2022 00:00:00 +0000</pubDate>  
  
  
  <atom:author>
    <atom:name>Jürgen Fuhrmann</atom:name>
  </atom:author>
        
</item>

<item>
  <title>
    <![CDATA[  Julia: Project Workflow Recommendations  ]]>
  </title>
  <link> https://j-fu.github.io/marginalia/julia/project-workflow/index.html </link>
  <guid> https://j-fu.github.io/marginalia/julia/project-workflow/index.html </guid>
  <description>
    <![CDATA[  Julia: Project Workflow.  ]]>
  </description>  
  
  <content:encoded>
    <![CDATA[  <h1 id="julia_project_workflow_recommendations">Julia: Project Workflow Recommendations</h1>
<p><div class="franklin-toc"><ol><li>Rationale</li><li>Recommendations<ol><li>Generate the project directory itself as a package</li><li>Manifest or not ?</li><li>Always start Julia from the package root</li><li>Activate the project environment in notebooks and scripts</li><li>Consider using DrWatson.jl</li><li>A sample project tree</li><li>New packages can evolve from the project code</li></ol></li><li>Summary</li></ol></div> </p>
<p>The term &quot;project&quot; in this post corresponds to the term &quot;application&quot; in <a href="https://pkgdocs.julialang.org/v1/glossary/#Glossary">package manager glossary</a></p>
<h2 id="rationale">Rationale</h2>
<p>Some ideas on basic julia workflow  are given  <a href="https://j-fu.github.io/marginalia/julia/basic-workflow">here</a>. For a larger project, structuring of the project code is essential for many reasons, some of them are:</p>
<ul>
<li><p>Different project scripts and Pluto notebooks may share some parts of the code, and you want to avoid <a href="https://en.wikipedia.org/wiki/Don&#37;27t_repeat_yourself">repeating yourself</a>.</p>
</li>
<li><p>Modularization of the project code should facilitate maintainability and extendability.</p>
</li>
<li><p>May be some of the code slowly turns into a package.</p>
</li>
<li><p>You want to have unit testing available in the project.</p>
</li>
<li><p>The whole project directory <em>still</em> shall be shareable with collaborators in a reproducible way.</p>
</li>
</ul>
<p>Morevover, it is important to prevent package compatibility clashes between different projects. Therefore, perhaps, the most important feature of the approach described consists in the idea that each project has its own package environment, as described in <a href="https://j-fu.github.io/marginalia/julia/basic-workflow/#record_project_dependencies_in_reproducible_environments">&quot;Basic Workflow&quot;</a>.</p>
<h2 id="recommendations">Recommendations</h2>
<p>The following recommendations are partially inspired by B. Kaminski&#39;s post on  <a href="https://bkamins.github.io/julialang/2020/05/18/project-workflow.html">project workflow</a> and  the  <a href="https://github.com/JuliaDynamics/DrWatson.jl">DrWatson.jl</a> package by G. Datseris.</p>
<h3 id="generate_the_project_directory_itself_as_a_package">Generate the project directory itself as a package</h3>
<p>Name this e.g. <code>MyProject</code>. Use<a href="https://pkgdocs.julialang.org/v1/creating-packages/"><code>Pkg.generate</code></a> or <a href="https://github.com/invenia/PkgTemplates.jl">PkgTemplates.jl</a>. Unlike a published Julia package, this  <em>project-package</em> will remain not be registered in a Julia package registry, its code will be shared directly via git repository urls.  Developing the project in such a project-package has the following advantages:</p>
<ul>
<li><p>Straightforward way to share  the code in the <code>src</code> folder among different project scripts and notebooks based on one shared environment via <code>using MyProject</code>.</p>
</li>
<li><p>Straightforward availability of Julia&#39;s  test and documentation functionality for the project.</p>
</li>
<li><p>Reproducibility due to dependencies recorded in the project environment &#40;files <code>Project.toml</code> and <code>Manifest.toml</code>&#41;.</p>
</li>
</ul>
<h3 id="manifest_or_not">Manifest or not ?</h3>
<p>Should the <code>Manifest.toml</code> be checked into the project repository or not ? The answer is - your mileage may vary.</p>
<p>Pro Checking in the manifest file:</p>
<ul>
<li><p>Strong reproducibility of the computational results</p>
</li>
<li><p>Starting with Julia 1.11, there can be different Manifest files for each Julia minor version &#40;e.g. <code>Manifest-v1.11.toml</code>&#41;, checking in the respective manifests can allow to use different Julia versions.</p>
</li>
<li><p>Subpackages in relative paths can only be found via the <code>Manifest.toml</code> &#40;for Julia &lt;1.11&#41;</p>
</li>
</ul>
<p>Pro not checking in the manifest file:</p>
<ul>
<li><p>Strong reproducibility is required when publishing results, not during development, where experimentation is ubiquitous</p>
</li>
<li><p>Dependency version checking can be managed via the <code>&#91;compat&#93;</code> section in <code>Project.toml</code></p>
</li>
<li><p>With Julia &lt;1.11, checking in the manifest file requires that all project collaborators use the same Julia version</p>
</li>
<li><p>Subpackages in relative paths can be found via the <code>&#91;sources&#93;</code> section of Project.toml  &#40;for Julia &gt;&#61;1.11&#41;</p>
</li>
<li><p>Successful tests with different dependency versions are a sign of robustness of the package code.  Diverging results with different Julia versions or different versions of dependencies hint on possible problems of the project code or the packages.</p>
</li>
<li><p>Easy unit tests on different Julia versions</p>
</li>
</ul>
<h3 id="always_start_julia_from_the_package_root">Always start Julia from the package root</h3>
<ul>
<li><p>When working with the project, always run julia from the package root with the package environment activated: <code>julia --project&#61;.</code> </p>
</li>
</ul>
<h3 id="activate_the_project_environment_in_notebooks_and_scripts">Activate the project environment in notebooks and scripts</h3>
<p>Project specific scripts and Pluto notebooks would reside in a  subdirectory  and call <code>Pkg.activate&#40;joinpath&#40;@__DIR__,&quot;..&quot;&#41;&#41;</code>  to activate the <code>MyProject</code> environment.  As a consequence, in the notebooks Pluto&#39;s in-built package manager will be disabled and the project specific notebooks will share the <code>MyProject</code> environment and <em>cannot be shared independent from the <code>MyProject</code> tree</em> &#40;If independent sharing is desired, common project code can be collected into a package residing in <code>packages</code> and registered in a registry; registering <code>MyProject</code> itself as a package is not recommended.  – More about this in another post&#41;.</p>
<h3 id="consider_using_drwatsonjl">Consider using DrWatson.jl</h3>
<p>You may use <a href="https://github.com/JuliaDynamics/DrWatson.jl">DrWatson.jl</a> for managing subdirectory access, simulation results and version tagging. By explicitely activating the project environment at the start of Julia or in the notebook Pkg cell, you can avoid <code>@quickactivate</code> and  avoid putting <code>using DrWatson</code> into script files and notebooks for the sole purpose of activating the common environment. See also <a href="https://github.com/JuliaDynamics/DrWatson.jl/issues/261">this discussion</a>.</p>
<h3 id="a_sample_project_tree">A sample project tree</h3>
<p>A sample project tree could e.g. look like this</p>
<pre><code class="language-julia">MyProject/
├── src
│   └── MyProject.jl
├── docs
│   ├── make.jl
│   ├── Project.toml
│   └── src
│       └── index.md
├── LICENSE
├── notebooks
│   └── demo-notebook.jl
├── Project.toml
├── README.md
├── scripts
│   └── demo-script.jl
├── papers
├── etc
│   ├── runpluto.jl
│   └── instantiate.jl
└── test
    └── runtests.jl</code></pre>
<p>The essential role of these files is as follows:</p>
<ul>
<li><p><code>Project.toml</code>: The project file describes the project on a high level. It lists packages used by the prokject together with version compatibility constraints  <a href="https://pkgdocs.julialang.org/v1/toml-files/#Project-and-Manifest">&#40;see documentation&#41;</a></p>
</li>
<li><p><code>LICENSE</code>: License of the project. By default it is the MIT license</p>
</li>
<li><p><code>README.md</code>: This file</p>
</li>
<li><p><code>src</code>: Subdirectory for project specific code as part of the MyProject package representing the project.</p>
</li>
<li><p><code>test</code>: Unit tests for project code in <code>src</code>. Could include something from <code>scripts</code>, <code>notebooks</code>.</p>
</li>
<li><p><code>scripts</code>, <code>notebooks</code>: &quot;Frontend&quot; code for creating project results</p>
</li>
<li><p><code>papers</code>: &quot;Wer schreibt, der bleibt&quot; - besides of coding, you probably should publish your results...</p>
</li>
<li><p><code>docs</code>: Sources for the documentation created with <code>Documenter.jl</code></p>
</li>
<li><p><code>etc</code>: Service code</p>
</li>
</ul>
<p>Using <a href="https://github.com/tpapp/PkgSkeleton.jl">PkgSkeleton.jl</a>, you can generate these files: Download and unpack the corresponding project skeleton <a href="https://j-fu.github.io/marginalia/assets/project-skeleton.zip">project-skeleton.zip</a>. Then invoke</p>
<pre><code class="language-julia">julia&gt; using PkgSkeleton
julia&gt; PkgSkeleton.generate&#40;&quot;MyProject&quot;; templates&#61;&#91;&quot;project-skeleton&quot;&#93;&#41;</code></pre>
<p>Feel free to adapt the generated directory tree to your needs and don&#39;t forget to make a git repository out of it as early as possible.</p>
<h3 id="new_packages_can_evolve_from_the_project_code">New packages can evolve from the project code</h3>
<p>For this purpose, optionally you can have a folder <code>packages</code> which contains other sub-packages which potentially can evolve into standalone, even registered packages. As <a href="https://github.com/JuliaLang/Pkg.jl/issues/1214">relative paths are recorded in Manifest.toml</a>, these are made available within the  project via <code>Pkg.develop&#40;path&#61;&quot;packages/MySubPackage&quot;&#41;</code>. Starting wit Julia 1.11, <code>Project.toml</code> can have a <a href="https://pkgdocs.julialang.org/dev/toml-files/#The-&#91;sources&#93;-section"><code>&#91;sources&#93;</code> section</a> which can contain a relative path for a subpackage. Either way, using this approach, the  whole project  tree including sub-packages  will stay relocateable.</p>
<ul>
<li><p>This allows for easy start of low key package development. At a later stage, <code>MySubPackage</code> could be registered as a Julia package while still residing in the project tree, or even removed from the project tree without affecting  scripts depending on it – once registered, the package can be added to the project environment via <code>Pkg.add</code> instead of <code>Pkg.develop</code>, or just removed from the <code>&#91;sources&#93;</code> section.</p>
</li>
</ul>
<h2 id="summary">Summary</h2>
<ul>
<li><p>Script functionality should be developed in functions, avoiding global variables</p>
</li>
<li><p>Create a project specific environment as a project-package</p>
</li>
<li><p>Use the REPL and  Revise.jl, start julia in the activated project environment</p>
</li>
<li><p>Place shared code among project specific  scripts or  notebooks either in the <code>src</code> subdirectory as part of the project-package, or in a  sub-package in a subdirectory of the project-package</p>
</li>
<li><p>Separate namespaces of scripts by using  modules</p>
</li>
<li><p>Activate the shared project environment of the project-package in project specific Pluto notebooks. </p>
</li>
<li><p>Write tests and examples</p>
</li>
</ul>
<p>By taking advantage of Julia&#39;s best-in-class package management facilities, the proposed approach goes a long way in the direction of maintaining sustainable research software. From a <a href="https://de.slideshare.net/andreas.zeller/sustainable-research-software">talk by A. Zeller</a>:</p>
<ol>
<li><p>Have a repo ✓</p>
</li>
<li><p>Anyone can build ✓</p>
</li>
<li><p>Have tests ✓</p>
</li>
<li><p>Be open for extensions ✓</p>
</li>
<li><p>Have examples ✓</p>
</li>
</ol>
<p>
<hr size="5" noshade>
 <strong>Update history</strong></p>
<ul>
<li><p>2025-03-29: Switch ot PkgSkeleton for the template</p>
</li>
<li><p>2024-07-31: Julia 1.11</p>
</li>
<li><p>2023-04-24: Intermediate headers</p>
</li>
<li><p>2022-02-09: RSS</p>
</li>
<li><p>2021-12-02: The term &quot;project&quot; in this post corresponds to the term &quot;application&quot; in <a href="https://pkgdocs.julialang.org/v1/glossary/#Glossary">package manager glossary</a>.</p>
</li>
<li><p>2021-11-15: Initial version </p>
</li>
</ul>
 ]]>
  </content:encoded>
    
  <pubDate>Wed, 09 Feb 2022 00:00:00 +0000</pubDate>  
  
  
  <atom:author>
    <atom:name>Jürgen Fuhrmann</atom:name>
  </atom:author>
        
</item>

<item>
  <title>
    <![CDATA[    ]]>
  </title>
  <link> https://j-fu.github.io/marginalia/julia/unionize/index.html </link>
  <guid> https://j-fu.github.io/marginalia/julia/unionize/index.html </guid>
  <description>
    <![CDATA[  Julia: Unionize your collections&#33;  ]]>
  </description>  
  
  <content:encoded>
    <![CDATA[  <h1 id="13633231208144796923"></h1><iframe style="height:10500px" width="100%" frameborder="0" src="https://j-fu.github.io/marginalia/assets/unionize.html"> </iframe> ]]>
  </content:encoded>
    
  <pubDate>Wed, 09 Feb 2022 00:00:00 +0000</pubDate>  
  
  
  <atom:author>
    <atom:name>Jürgen Fuhrmann</atom:name>
  </atom:author>
        
</item>

<item>
  <title>
    <![CDATA[  Julia: Basic Workflow Recomendations  ]]>
  </title>
  <link> https://j-fu.github.io/marginalia/julia/basic-workflow/index.html </link>
  <guid> https://j-fu.github.io/marginalia/julia/basic-workflow/index.html </guid>
  <description>
    <![CDATA[  Julia: Basic Workflow.  ]]>
  </description>  
  
  <content:encoded>
    <![CDATA[  <h1 id="julia_basic_workflow_recomendations">Julia: Basic Workflow Recomendations</h1>
<p><div class="franklin-toc"><ol><li>Never leave Julia and  write code in functions<ol><li><a href="https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-global-variables">Avoid  untyped global variables </a></li><li>Load code into the REPL via <code>include&#40;&#41;</code></li><li>Think about wrapping code into modules</li><li>Load modules into the REPL via <code>using</code></li></ol></li><li>Use Revise.jl to have modified code reloading automatically<ol><li>Load code into the REPL via <code>Revise.includet&#40;&#41;</code></li><li>Loading modules into the REPL via <code>using</code> allows to track all included files</li></ol></li><li>Record project dependencies in reproducible environments<ol><li>Global environment</li><li>Local environments</li><li>Enviroment stacking</li><li>Shared &#40;&quot;<code>@</code>&quot;&#41; Environments</li><li>Further info</li></ol></li></ol></div> </p>
<p>These workflow hints have been developed from my own experience and are essentially an illustration of the <a href="https://docs.julialang.org/en/v1/manual/workflow-tips">workflow tips</a>  found in the Julia documentation. </p>
<h2 id="never_leave_julia_and_write_code_in_functions">Never leave Julia and  write code in functions</h2>
<p>Many available Julia examples and  the mindset influenced by Matlab or Python suggest  that code is written in scripts where  computations are performed in the global context. E.g.  a script <code>MyScript.jl</code> would look like:</p>
<pre><code class="language-julia">using Package1
using Package2# computations here
...</code></pre>
<p>and executed like</p>
<pre><code class="language-julia">&#36; julia MyScript.jl</code></pre>
<p>However, for Julia this is a bad idea for at  least two reasons:</p>
<ul>
<li><p>Type-stable action of Julia&#39;s just-in-time compiler is possible only for functions, so this code does not optimize well</p>
</li>
<li><p>One encounters precompilation time hiatus when running after each modified  version</p>
</li>
</ul>
<h3 id="a_hrefhttpsdocsjulialangorgenv1manualperformance-tipsavoid-global-variablesavoid_untyped_global_variables"><a href="https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-global-variables">Avoid  untyped global variables </a></h3>
<p>Develop any code in functions. E.g. <code>MyScript.jl</code> could look like:</p>
<pre><code class="language-julia">using Package1
using Package2function main&#40;; kwarg1&#61;1, kwarg2&#61;2&#41;
 # action here 
end</code></pre>
<h3 id="load_code_into_the_repl_via_include">Load code into the REPL via <code>include&#40;&#41;</code></h3>
<p>Always invoke the code from within a running julia instance. In this   case you encounter the <a href="https://docs.julialang.org/en/v1/manual/workflow-tips/#REPL-based-workflow">Read-Eval-Print-Loop &#40;REPL&#41;</a> of Julia. You don&#39;t need to leave julia for restarting modified code &#40;except in the case when you re-define a constant or a struct&#41;. Just reload the code by repeating the <code>include</code> statement:</p>
<pre><code class="language-julia">&#36; julia
julia&gt; include&#40;&quot;MyScript.jl&quot;&#41;
julia&gt; main&#40;kwarg1&#61;5&#41;</code></pre>
<h3 id="think_about_wrapping_code_into_modules">Think about wrapping code into modules</h3>
<p>The previous example can be enhanced by wrapping the code of the script into a module. This has the advantage that you can load different scripts into the same session without name clashes.</p>
<pre><code class="language-julia">Module MyScriptusing Package1
using PackageNfunction main&#40;; kwarg1&#61;1, kwarg2&#61;2&#41;
 # action here 
endend</code></pre>
<pre><code class="language-julia">&#36; julia
julia&gt; include&#40;&quot;MyScript.jl&quot;&#41;
julia&gt; MyScript.main&#40;kwarg1&#61;5&#41;</code></pre>
<h3 id="load_modules_into_the_repl_via_using">Load modules into the REPL via <code>using</code></h3>
<p>Alternatively, load code via <code>using</code>. Once you have mastered modules and ensured that the file name corresponds to the module name, you can  load code via <code>using</code>. In order to allow for this, you need to ensure to have the directory containing <code>MyScript.jl</code> &#40;e.g. the current directory <code>pwd&#40;&#41;</code>&#41; on the <a href="https://docs.julialang.org/en/v1/base/constants/#Base.LOAD_PATH"><code>LOAD_PATH</code></a>:</p>
<pre><code class="language-julia">&#36; julia
julia&gt; push&#33;&#40;LOAD_PATH,pwd&#40;&#41;&#41;
julia&gt; using MyScript
julia&gt; MyScript.main&#40;kwarg1&#61;5&#41;</code></pre>
<p><code>LOAD_PATH</code> can also be passed to Julia as an environment variable defined before the invocation of julia. In order to allow this to work, the directory of <code>MyScript.jl</code><em>should not constitute an <a href="https://j-fu.github.io/marginalia/julia/basic-workflow/#record_your_project_dependencies_in_reproducible_environments">environment</a></em>, i.e. it should contain neither a <code>Project.toml</code> nor a <code>Manifest.toml</code> file.</p>
<h2 id="use_revisejl_to_have_modified_code_reloading_automatically">Use Revise.jl to have modified code reloading automatically</h2>
<p>In the previous examples, re-loading the code after modifications required to re-run the include statement. The package <a href="https://github.com/timholy/Revise.jl">Revise.jl</a> exports a function <code>includet</code> which triggers automatic recompilation  if the source code of the script file or of packages used therein has been modified.</p>
<p>In order to set this up, after invoking <code>Pkg.add&#40;&quot;Revise&quot;&#41;</code> once, place the following into the Julia startup file <code>.julia/config/startup.jl</code> in your home directory:</p>
<pre><code class="language-julia">using Revise</code></pre>
<h3 id="load_code_into_the_repl_via_reviseincludet">Load code into the REPL via <code>Revise.includet&#40;&#41;</code></h3>
<p>You would then run:</p>
<pre><code class="language-julia">&#36; julia -i
julia&gt; includet&#40;&quot;MyScript.jl&quot;&#41;
julia&gt; MyScript.main&#40;kwarg1&#61;5&#41;</code></pre>
<p>After having modified <code>MyScript.jl</code>, just another  invocation of <code>MyScript.main&#40;&#41;</code>  would see the changes. See also the corresponding hints in the <a href="https://docs.julialang.org/en/v1/manual/workflow-tips/#Revise-based-workflows">Julia documentation</a>.</p>
<h3 id="loading_modules_into_the_repl_via_using_allows_to_track_all_included_files">Loading modules into the REPL via <code>using</code> allows to track all included files</h3>
<p>If <code>MyScript.jl</code> itself uses <code>include&#40;&#41;</code> to load more code, <code>Revise.jl</code> is unable to track changes in the included code if <code>MyScript.jl</code> has been loaded via <code>includet</code>. This problem however is mitigated by <a href="https://j-fu.github.io/marginalia/julia/basic-workflow/#load_code_into_the_repl_via_using">loading <code>MyScript.jl</code> via <code>using</code></a>. This is true as well for modules and packages under development loaded into the script via <code>using</code> or <code>import</code>. In particular, this way, <code>Revise.jl</code> also works in <a href="https://github.com/fonsp/Pluto.jl">Pluto notebooks</a> when the inbuilt package manager has been disabled.</p>
<h2 id="record_project_dependencies_in_reproducible_environments">Record project dependencies in reproducible environments</h2>
<p>In julia, an <a href="https://docs.julialang.org/en/v1/manual/code-loading/#Environments">environment</a> determines which code is loaded via <code>import X</code> and <code>using X</code>. An environment can be described using a <code>Project.toml</code> file in a certain directory. This file contains a list of packages available for loading via <code>import</code> or <code>using</code>.</p>
<h3 id="global_environment">Global environment</h3>
<p>By default, packages added to the Julia installation are recorded in the default <em>global environment</em>:</p>
<pre><code class="language-julia">&#36; julia
julia&gt; using Pkg
julia&gt; Pkg.add&#40;&quot;Package1&quot;&#41;</code></pre>
<p>This results in  corresponding entries in <code>.julia/environments/vx.y/Project.toml</code>  and <code>.julia/environments/vx.y/Manifest.toml</code>  &#40;where <code>x.y</code> stands for your installed Julia version, e.g. 1.10&#41;. If no other measures are taken, all your julia code will look into this environment in order find the a package to be loaded via <code>using</code> or <code>import</code>.</p>
<p>Sharing this global  environment between all your different projects is risky because of possible conflicts in package version requirements. In addition, relying on the global environment makes it hard to share your code with others, as you would have to find a way to communicate the names of the  packages &#40;with versions&#41; which they need to install to run your code in a reproducible way.</p>
<h3 id="local_environments">Local environments</h3>
<p><em>Local environments</em> provide a remedy.</p>
<p>Assume that an  <em>application</em> is Julia code residing in a given directory <code>MyApp</code>, uses one or several other Julia packages and is not intended to be invoked from other packages or applications.  Set up an environment in  the project directory in the following way:</p>
<pre><code class="language-julia">&#36; cd MyApp
&#36; julia --project&#61;.
julia&gt; using Pkg
julia&gt; Pkg.add&#40;&quot;Package1&quot;&#41;
julia&gt; Pkg.add&#40;&quot;Package2&quot;&#41;
&#36; exit&#40;&#41;</code></pre>
<p>This creates an  environment in <code>MyApp</code> directory  described by the two files <code>MyApp/Project.toml</code> and <code>MyApp/Manifest.toml</code>. The <code>Project.toml</code> file lists the packages added to the environment. In addition, the <code>Manifest.toml</code> file a holds the information about the exact versions of all Julia packages used by the project.</p>
<p>After setting up the environment like this, you can  perform</p>
<pre><code class="language-julia">&#36; cd MyApp
&#36; julia --project&#61;.</code></pre>
<p>and work in the environment. All packages added  to Julia in this case are recorded in <code>MyApp</code> instead of <code>.julia/environments/vx.y/</code>. </p>
<p><code>Project.toml</code>  should be checked into version control along with the source code. If you took care about adding all necessary dependencies to the local environment, after checking out your code, another project collaborator can easily install all dependencies via</p>
<pre><code class="language-julia">&#36; cd MyApp
&#36; julia --project&#61;.
&#36; julia&gt; using Pkg
&#36; julia&gt; Pkg.instantiate&#40;&#41;</code></pre>
<p>If <code>Manifest.toml</code> is distributed and checked into version control along with <code>Project.toml</code>, <code>instantiate</code> will install the exact same package versions as recorded in the manifest.</p>
<h3 id="enviroment_stacking">Enviroment stacking</h3>
<p>After activating a local environment, packages in the global environment still will be visible to your project. You can use this to keep available utilities your project should not depend upon, but which are useful during development. This could e.g. be <code>BenchmarkTools</code>, <code>JuliaFormatter</code> etc.</p>
<h3 id="shared_environments">Shared &#40;&quot;<code>@</code>&quot;&#41; Environments</h3>
<p>Since Julia 1.7 it is possible to easily work with different more or less global environments:</p>
<pre><code class="language-julia">&#36; julia --project&#61;@myenv</code></pre>
<p>calls Julia and activates the environment <code>.julia/environments/myenv</code></p>
<h3 id="further_info">Further info</h3>
<ul>
<li><p><a href="https://modernjuliaworkflows.github.io/">Modern Julia Workflows</a>:  Best practices for Julia development.</p>
</li>
<li><p>My <a href="https://www.wias-berlin.de/people/fuhrmann/AdSciComp-WS2223/week3/#reproducibility_infrastructure_of_the_julia_language">talk</a> on the reproducibility infrastructure of the Julia language</p>
</li>
<li><p>Documentation on <a href="https://pkgdocs.julialang.org/v1/environments/">environments</a> and <a href="https://pkgdocs.julialang.org/v1/toml-files/"><code>Project.toml</code> and <code>Manifest.toml</code></a>.</p>
</li>
<li><p>Pluto notebooks have their own <a href="https://github.com/fonsp/Pluto.jl/wiki/&#37;F0&#37;9F&#37;8E&#37;81-Package-management">built-in package management</a> and by default     contain a <code>Project.toml</code> and a <code>Manifest.toml</code> file to ensure portability.</p>
</li>
<li><p><a href="https://jkrumbiegel.com/pages/2022-08-26-pkg-introduction/">Blogpost</a> by Julius Krumbiegel for another take on Julia environments.</p>
</li>
</ul><hr size="5" noshade><p><strong>Update history</strong></p>
<ul>
<li><p>2024-10-07: Package directories on LOAD_PATH should not contain Project.toml; multiple reformulations</p>
</li>
<li><p>2024-10-02: Make Manifest check-in optional, upvote  &quot;Modern julia workflows&quot;</p>
</li>
<li><p>2023-10-17: Link to modern julia workflows</p>
</li>
<li><p>2023-04-24: Smaller improvements</p>
</li>
<li><p>2022-11-06: <code>@</code> environments &#40;since Julia 1.7&#41; &#43; LOAD_PATH, link to my talk on Julia&#39;s reproducibility infrastructure</p>
</li>
<li><p>2022-09-01: Link to <a href="https://jkrumbiegel.com/pages/2022-08-26-pkg-introduction/">blogpost</a> by Julius Krumbiegel</p>
</li>
<li><p>2022-02-09: RSS</p>
</li>
<li><p>2021-11-15: Initial version</p>
</li>
</ul>
 ]]>
  </content:encoded>
    
  <pubDate>Wed, 09 Feb 2022 00:00:00 +0000</pubDate>  
  
  
  <atom:author>
    <atom:name>Jürgen Fuhrmann</atom:name>
  </atom:author>
        
</item>

<item>
  <title>
    <![CDATA[  Julia: Achieving Performance   ]]>
  </title>
  <link> https://j-fu.github.io/marginalia/julia/achieving-performance/index.html </link>
  <guid> https://j-fu.github.io/marginalia/julia/achieving-performance/index.html </guid>
  <description>
    <![CDATA[  Julia: Achieving Performance.  ]]>
  </description>  
  
  <content:encoded>
    <![CDATA[  <h1 id="julia_achieving_performance">Julia: Achieving Performance </h1>
<div class="franklin-toc"><ol><li>Other resources on this topic</li><li>&quot;Measure performance with @time and pay attention to memory allocations&quot;</li><li>&quot;REPL based workflow&quot;</li><li>&quot;Avoid untyped global variables&quot;</li><li>&quot;Pre-allocate outputs&quot;</li><li>&quot;Avoid changing the type of a variable&quot; </li><li>&quot;More dots: fuse vectorized operations&quot;</li><li>&quot;Be aware of when Julia avoids specializing&quot;</li><li>&quot;Performance annotations&quot;</li></ol></div>
<p>In  order  to  let  newcomers  to the  language  experience  the  real performance potential of Julia it  is important to raise the awareness for the corresponding &quot;tricks&quot; early on.</p>
<p>This text results from an effort  to improve the code performance of a piece  of experimental  research  code  which has  been  written by  a colleague new  to Julia. It   describes the steps  taken  to  get runtime down from 13s to 0.07s and allocations form 763.08 M allocations to 86.</p>
<h2 id="other_resources_on_this_topic">Other resources on this topic</h2>
<ul>
<li><p>It turned out that all necessary information is described on the <a href="https://docs.julialang.org/en/v1/manual/performance-tips/#man-performance-tips">Julia performance tips</a> page, this text should be understood as an additional explanation from a bit different angle and a bit more in layman&#39;s terms.  The corresponding links to the documentation sections are provided.</p>
</li>
<li><p>Also, the <a href="https://www.stochasticlifestyle.com/7-julia-gotchas-handle/">7 Julia Gotchas</a> still are worth to read in this context.</p>
</li>
<li><p>UPDATE </p>
<ul>
<li><p>2021-12-01: Philippe Mainçon: <a href="https://blog.sintef.com/industry-en/writing-type-stable-julia-code/">Writing type-stable Julia code</a></p>
</li>
<li><p>2022-09-09: Jacob Nybo Nissen: <a href="https://biojulia.net/post/hardware/">What scientists must know about hardware to write fast code</a></p>
</li>
<li><p>2022-09-09: <a href="https://j-fu.github.io/marginalia/julia/unionize">Unionize your collections</a></p>
</li>
</ul>
</li>
</ul>
<h2 id="measure_performance_with_time_and_pay_attention_to_memory_allocations">&quot;Measure performance with @time and pay attention to memory allocations&quot;</h2>
<p><a href="https://docs.julialang.org/en/v1/manual/performance-tips/#Measure-performance-with-&#91;@time&#93;&#40;@ref&#41;-and-pay-attention-to-memory-allocation">Julia docs 🔗</a></p>
<p>One allocation can use the time of several hundred floating point multiplications. </p>
<p>In order to understand the role of allocations ist is useful to  understand the concept of <a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html#the-stack-and-the-heap">stack and heap</a>, which is fundamental for any modern computer language &#40;as e.g. for Rust in the previous link&#41;.</p>
<p>An allocation reserves memory from the memory pool of the operating system &#40;&quot;heap&quot;&#41; and is expensive  as the  interaction  with the  operating  system  kernel needs certain amount of bookkeeping. Fundamentally, an allocation happens in  any language when  creating an object of a priori unknown size, e.g. an  array of length unknown at compile time. Objects with a priori known size, as e.g. structs  can be placed on top of a piece of memory pre-allocated during program start called &quot;stack&quot;, with almost no bookkeeping as no allocation from the system is necessary.</p>
<p>In Julia, the  <a href="https://docs.julialang.org/en/v1/base/base/#Base.@time"><code>@time</code></a> macro can be used to find allocations. Besides the execution time it prints  the number of allocations happening when running  the measured expression. There is also the possibility to run the code with  <a href="https://docs.julialang.org/en/v1/manual/command-line-options/#command-line-options"><code>julia --track-allocation</code></a>.</p>
<p>The idea is then &quot;hunt&quot; allocations by placing temporary @time statements in critical places of the code. In particular, removing allocations from &quot;hot loops&quot; with will pay off. </p>
<h2 id="repl_based_workflow">&quot;REPL based workflow&quot;</h2>
<p><a href="https://docs.julialang.org/en/v1/manual/workflow-tips/#REPL-based-workflow">Julia docs 🔗</a> </p>
<p>During code development it is  helpful never to leave the Julia command line and to include the code after each change using the <code>include</code> statement. This approach avoids Just-in-time &#40;JIT&#41; recompilation which is peformed at startup time.</p>
<p>For more intense projects it is worth to use <a href="https://github.com/timholy/Revise.jl">Revise.jl</a> for automatic handling of code updates instead of calling <code>include</code> again and again.</p>
<p>Also it may be worth to have a look at the <a href="https://www.julia-vscode.org/">Visual Studio Code</a> editing environment for working with Julia.</p>
<h2 id="avoid_untyped_global_variables">&quot;Avoid untyped global variables&quot;</h2>
<p><a href="https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-untyped-global-variables">Julia docs 🔗</a></p>
<p>Avoid to work with global variables. E.g. instead of</p>
<pre><code class="language-julia">a&#61;10 
b&#61;11function important&#40;x&#41;
   x&#61;5*a&#43;b
end@btime important&#40;10&#41;</code></pre>
<pre><code class="plaintext code-output">ArgumentError: Package BenchmarkTools not found in current path:
- Run `import Pkg; Pkg.add("BenchmarkTools")` to install the BenchmarkTools package.</code></pre>
<p>write</p>
<pre><code class="language-julia">a&#61;10
b&#61;11function important&#40;x,a,b&#41;
     x&#61;5*a&#43;b
end@btime important&#40;10,a,b&#41;</code></pre>
<pre><code class="plaintext code-output">LoadError: UndefVarError: @btime not defined
in expression starting at none:2
</code></pre>
<p>A more profound approach which would keep parameter lists  short may be the creation of a context <code>struct</code> which collects the parameters.</p>
<p>Alternatively, wrap the global context into a function </p>
<pre><code class="language-julia">function run&#40;&#41;
  a::Int&#61;10
  b::Int&#61;11  function important&#40;x&#41;
     x&#61;5*a&#43;b
  end
@btime important&#40;10&#41;
end
run&#40;&#41;</code></pre>
<pre><code class="plaintext code-output">LoadError: UndefVarError: @btime not defined
in expression starting at none:8
</code></pre>
<p>and ensure that <a href="https://docs.julialang.org/en/v1/manual/performance-tips/#man-performance-captured"><code>a</code> and <code>b</code> never change type</a> by <a href="https://docs.julialang.org/en/v1/manual/types/#Type-Declarations">type-annotating</a> them &#40;which is not possible for global variables in Julia versions &lt;1.8&#41;.</p>
<h5 id="rationale">Rationale:</h5>
<p>Julia assumes that a global variable can change its type anytime, so it needs to be wrapped  into a container &#40;&quot;boxing&quot;&#41; labeled with its current type. Handling these is expensive and manifests itself in additional allocations. Type changes of captured variables would have similar implications. In fact, this is very similar to the way e.g. python works with <em>any</em> variable.</p>
<h2 id="pre-allocate_outputs">&quot;Pre-allocate outputs&quot;</h2>
<p><a href="https://docs.julialang.org/en/v1/manual/performance-tips/#Pre-allocating-outputs">Julia docs 🔗</a></p>
<p>Pre-allocate memory e.g. for arrays needed in inner loops. In the case where array sizes are unknown a priori,  replace expressions like <code>F&#61;&#91;something&#40;i&#41; for i&#61;1:N&#93;</code>  by </p>
<pre><code class="language-julia">function Fnum&#40;F&#41;
  ...
  if length&#40;F&#41;&lt;N
    resize&#33;&#40;F,N&#41;
  end
  for i&#61;1:N 
     F&#91;i&#93;&#61;something&#40;i&#41;
  end
  ...  
end</code></pre>
<p>where <code>F</code> is initialized e.g. via <code>F&#61;zeros&#40;0&#41;</code> is created once and passed to <code>FNum</code>. </p>
<h5 id="rationale__2">Rationale:</h5>
<p>An expression like <code>F&#61;&#91;...&#93;</code> creates an array and allocates memory for it. If this happens for a temporay variable used in a function called many times, this becomes a massive performance hit. Therefore, it is better  to pre-allocate this   memory, pass it to the inner loop function and to  increase it on necessity &#40;leading only to few allocations if the hitherto length was too short&#41;.</p>
<h2 id="avoid_changing_the_type_of_a_variable">&quot;Avoid changing the type of a variable&quot; </h2>
<p><a href="https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-changing-the-type-of-a-variable">Julia docs 🔗</a></p>
<p>Replace <code>x&#61;0</code>, <code>x&#61;1</code>, etc. by <code>x&#61;0.0</code>, <code>x&#61;1.0</code> etc when it comes to declarations of variables later used as floating point values. </p>
<p>Another alternative is to <a href="https://docs.julialang.org/en/v1/manual/types/#Type-Declarations">type-annotate</a> variables when declaring them the first time: <code>x::FLoat64&#61;1</code>.</p>
<h5 id="rationale__3">Rationale:</h5>
<p>Setting <code>x&#61;1</code>, and writing  later <code>x&#61;2.0</code> changes the type of <code>x</code> and creates a <a href="https://docs.julialang.org/en/v1/manual/faq/#man-type-stability">type instability</a> with very much the same consequences as described above with respect to global variables. The <a href="https://docs.julialang.org/en/v1/manual/performance-tips/#man-code-warntype"><code>@code_warntype</code></a> macro can help to find corresponding situations.</p>
<h2 id="more_dots_fuse_vectorized_operations">&quot;More dots: fuse vectorized operations&quot;</h2>
<p><a href="https://docs.julialang.org/en/v1/manual/performance-tips/#More-dots:-Fuse-vectorized-operations">Julia docs 🔗</a></p>
<p>Replace vector expressions like </p>
<pre><code class="language-julia">u&#61;v-w</code></pre>
<p>by either </p>
<pre><code class="language-julia">u.&#61; v.-w</code></pre>
<p>or the equivalent </p>
<pre><code class="language-julia">@. u&#61;v-w</code></pre>
<h5 id="rationale__4">Rationale:</h5>
<p>Vector expressions without dot &quot;.&quot; result in handling each elementary expression in its own loop over vector length and creating  intermediate values which need to be allocated.</p>
<p>The dot tells Julia to <em>fuse</em> these loops, that means the Julia compiler creates exactly one loop which applies the operations component-wise instead of creating code for each operation apart. This removes multiple loop bookkeeping overheads and avoids allocation of memory for intermediate expressions.</p>
<p>Connected to his hint is the fact that unlike with python/numpy, in Julia there is no need to &quot;vectorize&quot; code for performance. Writing your own loops or writing fused vector expressions is sufficient to get full performance with Julia. </p>
<h2 id="be_aware_of_when_julia_avoids_specializing">&quot;Be aware of when Julia avoids specializing&quot;</h2>
<p><a href="https://docs.julialang.org/en/v1/manual/performance-tips/#Be-aware-of-when-Julia-avoids-specializing">Julia docs 🔗</a></p>
<p>Moving functions parametrizing the code from global variables to function parameters creates  a new source of allocations. This can be  removed by type-annotating the newly introduced function parameters.</p>
<p>E.g. for <code>func</code> being a function  parameter of <code>g</code>, replace</p>
<pre><code class="language-julia">function  g&#40;func, a,b,c&#41;
...
end</code></pre>
<p>by</p>
<pre><code class="language-julia">function   g&#40;func::T, a, b,c&#41; where &#123;T&#125;
...
end</code></pre>
<h4 id="rationale__5">Rationale:</h4>
<p>Usually, if Julia is aware of the types of parameters passed to a function, it  creates specialized code for each combination of type signatures. E.g.  with a definition <code>f&#40;x&#41;&#61;x*x</code> Julia is triggered to create  code for floating point numbers when calling <code>f&#40;2.0&#41;</code> and  for rational numbers when calling <code>f&#40;2//1&#41;</code>.  This behavior is called <em>specialization</em>.</p>
<p>There are exceptions to this rule. One exception are function parameters. Julia by default does not specialize on function parameter types &#40;in Julia, each function has its own type&#41;, resulting in an allocation when calling the first version of <code>g&#40;func,a,b,c&#41;</code>, even when the body of <code>g</code> is &quot;allocation free&quot;.</p>
<p>Type-annotating <code>func</code> in the parameter list of <code>g</code> with a <a href="https://docs.julialang.org/en/v1/base/base/#where">type parameter</a>  triggers Julia to create specialized code for each function passed.</p>
<h2 id="performance_annotations">&quot;Performance annotations&quot;</h2>
<p><a href="https://docs.julialang.org/en/v1/manual/performance-tips/#man-performance-annotations">Julia docs 🔗</a></p>
<p>Annotate  inner loops with <code>@fastmath @inbounds</code> to remove bounds checking and some speed constraints inherent to pure  IEEE floating point arithmetic.</p>
<p>
<hr size="5" noshade>
 <strong>Update history</strong></p>
<ul>
<li><p>2023-04-24: Smaller improvements</p>
</li>
<li><p>2022-09-09: Updates on other resources</p>
</li>
<li><p>2022-02-09: RSS</p>
</li>
<li><p>2021-11-15: Initial version</p>
</li>
</ul>
 ]]>
  </content:encoded>
    
  <pubDate>Wed, 09 Feb 2022 00:00:00 +0000</pubDate>  
  
  
  <atom:author>
    <atom:name>Jürgen Fuhrmann</atom:name>
  </atom:author>
        
</item>
</channel></rss>