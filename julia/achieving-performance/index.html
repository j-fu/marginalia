<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/marginalia/libs/highlight/github.min.css"> <link rel=stylesheet  href="/marginalia/css/franklin.css"> <link rel=stylesheet  href="/marginalia/css/poole_lanyon.css"> <link rel=stylesheet  href="/marginalia/css/adjust.css"> <link rel=icon  href="/marginalia/assets/favicon.png"> <title>Julia: Achieving Performance </title> <input type=checkbox  class=sidebar-checkbox  id=sidebar-checkbox > <div class=sidebar  id=sidebar > <div class=sidebar-item > <p>Marginalia</p> </div> <nav class=sidebar-nav > <a class="sidebar-nav-item " href="/marginalia/">Home</a> <a class="sidebar-nav-item " href="/marginalia/julia/">Julia</a> <a class="sidebar-nav-item " href="/marginalia/git/">Git</a> <a class="sidebar-nav-item " href="/marginalia/older-posts/">Older posts</a> </nav> <div class=sidebar-item > <p>&copy; JÃ¼rgen Fuhrmann.</p> </div> </div> <!-- Wrap is the content to shift when toggling the sidebar. We wrap the content to avoid any CSS collisions with our real content. --> <div class=wrap > <div class=masthead > <div class=container > <h3 class=masthead-title > <a href="/marginalia/" title=Home >Marginalia</a> </h3> </div> </div> </div> <div class="container content"> <div class=franklin-content ><h1 id=julia_achieving_performance ><a href="#julia_achieving_performance" class=header-anchor >Julia: Achieving Performance </a></h1> <ul> <li><p>2022-09-09: Updates on other resources</p> <li><p>2022-02-09: RSS</p> <li><p>2021-11-15: Initial version</p> </ul> <div class=franklin-toc ><ol><li><a href="#other_resources_on_this_topic">Other resources on this topic</a><li><a href="#measure_performance_with_time_and_pay_attention_to_memory_allocations">&quot;Measure performance with @time and pay attention to memory allocations&quot;</a><li><a href="#repl_based_workflow">&quot;REPL based workflow&quot;</a><li><a href="#avoid_global_variables">&quot;Avoid global variables&quot;</a><li><a href="#pre-allocate_outputs">&quot;Pre-allocate outputs&quot;</a><li><a href="#avoid_changing_the_type_of_a_variable">&quot;Avoid changing the type of a variable&quot; </a><li><a href="#more_dots_fuse_vectorized_operations">&quot;More dots: fuse vectorized operations&quot;</a><li><a href="#be_aware_of_when_julia_avoids_specializing">&quot;Be aware of when Julia avoids specializing&quot;</a><li><a href="#performance_annotations">&quot;Performance annotations&quot;</a></ol></div> <p>In order to let newcomers to the language experience the real performance potential of Julia it is important to raise the awareness for the corresponding &quot;tricks&quot; early on.</p> <p>This text results from an effort to improve the code performance of a piece of experimental research code which has been written by a colleague new to Julia. It describes the steps taken to get runtime down from 13s to 0.07s and allocations form 763.08 M allocations to 86.</p> <h2 id=other_resources_on_this_topic ><a href="#other_resources_on_this_topic" class=header-anchor >Other resources on this topic</a></h2> <ul> <li><p>It turned out that all necessary information is described on the <a href="https://docs.julialang.org/en/v1/manual/performance-tips/#man-performance-tips">Julia performance tips</a> page, this text should be understood as an additional explanation from a bit different angle and a bit more in layman&#39;s terms. The corresponding links to the documentation sections are provided.</p> <li><p>Also, the <a href="https://www.stochasticlifestyle.com/7-julia-gotchas-handle/">7 Julia Gotchas</a> still are worth to read in this context.</p> <li><p>UPDATE </p> <ul> <li><p>2021-12-01: Philippe MainÃ§on: <a href="https://blog.sintef.com/industry-en/writing-type-stable-julia-code/">Writing type-stable Julia code</a></p> <li><p>2022-09-09: Jacob Nybo Nissen: <a href="https://biojulia.net/post/hardware/">What scientists must know about hardware to write fast code</a></p> <li><p>2022-09-09: <a href="/marginalia/julia/unionize">Unionize your collections</a></p> </ul> </ul> <h2 id=measure_performance_with_time_and_pay_attention_to_memory_allocations ><a href="#measure_performance_with_time_and_pay_attention_to_memory_allocations" class=header-anchor >&quot;Measure performance with @time and pay attention to memory allocations&quot;</a></h2> <p><a href="https://docs.julialang.org/en/v1/manual/performance-tips/#Measure-performance-with-&#91;@time&#93;&#40;@ref&#41;-and-pay-attention-to-memory-allocatioan">Julia docs ðŸ”—</a></p> <p>One allocation can use the time of several hundred floating point multiplications. </p> <p>In order to understand the role of allocations ist is useful to understand the concept of <a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html#the-stack-and-the-heap">stack and heap</a>, which is fundamental for any modern computer language &#40;as e.g. for Rust in the previous link&#41;.</p> <p>An allocation reserves memory from the memory pool of the operating system &#40;&quot;heap&quot;&#41; and is expensive as the interaction with the operating system kernel needs certain amount of bookkeeping. Fundamentally, an allocation happens in any language when creating an object of a priori unknown size, e.g. an array of length unknown at compile time. Objects with a priori known size, as e.g. structs can be placed on top of a piece of memory pre-allocated during program start called &quot;stack&quot;, with almost no bookkeeping as no allocation from the system is necessary.</p> <p>In Julia, the <a href="https://docs.julialang.org/en/v1/base/base/#Base.@time"><code>@time</code></a> macro can be used to find allocations. Besides the execution time it prints the number of allocations happening when running the measured expression. There is also the possibility to run the code with <a href="https://docs.julialang.org/en/v1/manual/command-line-options/#command-line-options"><code>julia --track-allocation</code></a>.</p> <p>The idea is then &quot;hunt&quot; allocations by placing temporary @time statements in critical places of the code. In particular, removing allocations from &quot;hot loops&quot; with will pay off. </p> <h2 id=repl_based_workflow ><a href="#repl_based_workflow" class=header-anchor >&quot;REPL based workflow&quot;</a></h2> <p><a href="https://docs.julialang.org/en/v1/manual/workflow-tips/#REPL-based-workflow">Julia docs ðŸ”—</a> </p> <p>During code development it is helpful never to leave the Julia command line and to include the code after each change using the <code>include</code> statement. This approach avoids Just-in-time &#40;JIT&#41; recompilation which is peformed at startup time.</p> <p>For more intense projects it is worth to use <a href="https://github.com/timholy/Revise.jl">Revise.jl</a> for automatic handling of code updates instead of calling <code>include</code> again and again.</p> <p>Also it may be worth to have a look at the <a href="https://www.julia-vscode.org/">Visual Studio Code</a> editing environment for working with Julia.</p> <h2 id=avoid_global_variables ><a href="#avoid_global_variables" class=header-anchor >&quot;Avoid global variables&quot;</a></h2> <p><a href="https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-global-variables">Julia docs ðŸ”—</a></p> <p>Avoid to work with global variables. E.g. instead of</p> <pre><code class=language-julia >a&#61;10 
b&#61;11

function important&#40;x&#41;
   x&#61;5*a&#43;b
end

@btime important&#40;10&#41;</code></pre> <pre><code class="plaintext code-output">ArgumentError: Package BenchmarkTools not found in current path:
- Run `import Pkg; Pkg.add("BenchmarkTools")` to install the BenchmarkTools package.

</code></pre> <p>write</p> <pre><code class=language-julia >a&#61;10
b&#61;11

function important&#40;x,a,b&#41;
     x&#61;5*a&#43;b
end

@btime important&#40;10,a,b&#41;</code></pre> <pre><code class="plaintext code-output">LoadError: UndefVarError: @btime not defined
in expression starting at none:2
</code></pre> <p>A more profound approach which would keep parameter lists short may be the creation of a context <code>struct</code> which collects the parameters.</p> <p>Alternatively, wrap the global context into a function </p> <pre><code class=language-julia >function run&#40;&#41;
  a::Int&#61;10
  b::Int&#61;11

  function important&#40;x&#41;
     x&#61;5*a&#43;b
  end
@btime important&#40;10&#41;
end
run&#40;&#41;</code></pre> <pre><code class="plaintext code-output">LoadError: UndefVarError: @btime not defined
in expression starting at none:8
</code></pre> <p>and ensure that <a href="https://docs.julialang.org/en/v1/manual/performance-tips/#man-performance-captured"><code>a</code> and <code>b</code> never change type</a> by <a href="https://docs.julialang.org/en/v1/manual/types/#Type-Declarations">type-annotating</a> them &#40;which is not possible for global variables in Julia versions &lt;1.8&#41;.</p> <h5 id=rationale ><a href="#rationale" class=header-anchor >Rationale:</a></h5> <p>Julia assumes that a global variable can change its type anytime, so it needs to be wrapped into a container &#40;&quot;boxing&quot;&#41; labeled with its current type. Handling these is expensive and manifests itself in additional allocations. Type changes of captured variables would have similar implications. In fact, this is very similar to the way e.g. python works with <em>any</em> variable.</p> <h2 id=pre-allocate_outputs ><a href="#pre-allocate_outputs" class=header-anchor >&quot;Pre-allocate outputs&quot;</a></h2> <p><a href="https://docs.julialang.org/en/v1/manual/performance-tips/#Pre-allocating-outputs">Julia docs ðŸ”—</a></p> <p>Pre-allocate memory e.g. for arrays needed in inner loops. In the case where array sizes are unknown a priori, replace expressions like <code>F&#61;&#91;something&#40;i&#41; for i&#61;1:N&#93;</code> by </p> <pre><code class=language-julia >function Fnum&#40;F&#41;
  ...
  if length&#40;F&#41;&lt;N
    resize&#33;&#40;F,N&#41;
  end
  for i&#61;1:N 
     F&#91;i&#93;&#61;something&#40;i&#41;
  end
  ...  
end</code></pre> <p>where <code>F</code> is initialized e.g. via <code>F&#61;zeros&#40;0&#41;</code> is created once and passed to <code>FNum</code>. </p> <h5 id=rationale__2 ><a href="#rationale__2" class=header-anchor >Rationale:</a></h5> <p>An expression like <code>F&#61;&#91;...&#93;</code> creates an array and allocates memory for it. If this happens for a temporay variable used in a function called many times, this becomes a massive performance hit. Therefore, it is better to pre-allocate this memory, pass it to the inner loop function and to increase it on necessity &#40;leading only to few allocations if the hitherto length was too short&#41;.</p> <h2 id=avoid_changing_the_type_of_a_variable ><a href="#avoid_changing_the_type_of_a_variable" class=header-anchor >&quot;Avoid changing the type of a variable&quot; </a></h2> <p><a href="https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-changing-the-type-of-a-variable">Julia docs ðŸ”—</a></p> <p>Replace <code>x&#61;0</code>, <code>x&#61;1</code>, etc. by <code>x&#61;0.0</code>, <code>x&#61;1.0</code> etc when it comes to declarations of variables later used as floating point values. </p> <p>Another alternative is to <a href="https://docs.julialang.org/en/v1/manual/types/#Type-Declarations">type-annotate</a> variables when declaring them the first time: <code>x::FLoat64&#61;1</code>.</p> <h5 id=rationale__3 ><a href="#rationale__3" class=header-anchor >Rationale:</a></h5> <p>Setting <code>x&#61;1</code>, and writing later <code>x&#61;2.0</code> changes the type of <code>x</code> and creates a <a href="https://docs.julialang.org/en/v1/manual/faq/#man-type-stability">type instability</a> with very much the same consequences as described above with respect to global variables. The <a href="https://docs.julialang.org/en/v1/manual/performance-tips/#man-code-warntype"><code>@code_warntype</code></a> macro can help to find corresponding situations.</p> <h2 id=more_dots_fuse_vectorized_operations ><a href="#more_dots_fuse_vectorized_operations" class=header-anchor >&quot;More dots: fuse vectorized operations&quot;</a></h2> <p><a href="https://docs.julialang.org/en/v1/manual/performance-tips/#More-dots:-Fuse-vectorized-operations">Julia docs ðŸ”—</a></p> <p>Replace vector expressions like </p> <pre><code class=language-julia >u&#61;v-w</code></pre>
<p>by either </p>
<pre><code class=language-julia >u.&#61; v.-w</code></pre>
<p>or the equivalent </p>
<pre><code class=language-julia >@. u&#61;v-w</code></pre>
<h5 id=rationale__4 ><a href="#rationale__4" class=header-anchor >Rationale:</a></h5>
<p>Vector expressions without dot &quot;.&quot; result in handling each elementary expression in its own loop over vector length and creating  intermediate values which need to be allocated.</p>
<p>The dot tells Julia to <em>fuse</em> these loops, that means the Julia compiler creates exactly one loop which applies the operations component-wise instead of creating code for each operation apart. This removes multiple loop bookkeeping overheads and avoids allocation of memory for intermediate expressions.</p>
<p>Connected to his hint is the fact that unlike with python/numpy, in Julia there is no need to &quot;vectorize&quot; code for performance. Writing your own loops or writing fused vector expressions is sufficient to get full performance with Julia. </p>
<h2 id=be_aware_of_when_julia_avoids_specializing ><a href="#be_aware_of_when_julia_avoids_specializing" class=header-anchor >&quot;Be aware of when Julia avoids specializing&quot;</a></h2>
<p><a href="https://docs.julialang.org/en/v1/manual/performance-tips/#Be-aware-of-when-Julia-avoids-specializing">Julia docs ðŸ”—</a></p>
<p>Moving functions parametrizing the code from global variables to function parameters creates  a new source of allocations. This can be  removed by type-annotating the newly introduced function parameters.</p>
<p>E.g. for <code>func</code> being a function  parameter of <code>g</code>, replace</p>
<pre><code class=language-julia >function  g&#40;func, a,b,c&#41;
...
end</code></pre>
<p>by</p>
<pre><code class=language-julia >function   g&#40;func::T, a, b,c&#41; where &#123;T&#125;
...
end</code></pre>
<h4 id=rationale__5 ><a href="#rationale__5" class=header-anchor >Rationale:</a></h4>
<p>Usually, if Julia is aware of the types of parameters passed to a function, it  creates specialized code for each combination of type signatures. E.g.  with a definition <code>f&#40;x&#41;&#61;x*x</code> Julia is triggered to create  code for floating point numbers when calling <code>f&#40;2.0&#41;</code> and  for rational numbers when calling <code>f&#40;2//1&#41;</code>.  This behavior is called <em>specialization</em>.</p>
<p>There are exceptions to this rule. One exception are function parameters. Julia by default does not specialize on function parameter types &#40;in Julia, each function has its own type&#41;, resulting in an allocation when calling the first version of <code>g&#40;func,a,b,c&#41;</code>, even when the body of <code>g</code> is &quot;allocation free&quot;.</p>
<p>Type-annotating <code>func</code> in the parameter list of <code>g</code> with a <a href="https://docs.julialang.org/en/v1/base/base/#where">type parameter</a>  triggers Julia to create specialized code for each function passed.</p>
<h2 id=performance_annotations ><a href="#performance_annotations" class=header-anchor >&quot;Performance annotations&quot;</a></h2>
<p><a href="https://docs.julialang.org/en/v1/manual/performance-tips/#man-performance-annotations">Julia docs ðŸ”—</a></p>
<p>Annotate  inner loops with <code>@fastmath @inbounds</code> to remove bounds checking and some speed constraints inherent to pure  IEEE floating point arithmetic.</p>
<div class=page-foot >
  <div class=copyright >
    &copy; JÃ¼rgen Fuhrmann. License: <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode"> CC-BY-SA 4.0</a>. Last modified: March 08, 2023. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>.
Upon finding factual errors, typos etc. <a href=https://github.com/j-fu/marginalia/issues> raise an issue<a>.
<center>  <a href="/marginalia/feed.xml"> <img src="/marginalia/assets/rss.png" style="width:100px;"></a> </center>
  </div>
</div>


</div>
      </div>  
    </div> 
    
    
        <script src="/marginalia/libs/highlight/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();hljs.configure({tabReplace: '    '});</script>

    
    <label for=sidebar-checkbox  class=sidebar-toggle ></label>