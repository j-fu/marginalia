<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/marginalia/libs/highlight/github.min.css"> <link rel=stylesheet  href="/marginalia/css/franklin.css"> <link rel=stylesheet  href="/marginalia/css/poole_lanyon.css"> <link rel=stylesheet  href="/marginalia/css/adjust.css"> <link rel=icon  href="/marginalia/assets/favicon.png"> <title>Never leave Julia and write code in functions</title> <input type=checkbox  class=sidebar-checkbox  id=sidebar-checkbox > <div class=sidebar  id=sidebar > <div class=sidebar-item > <p>Marginalia</p> </div> <nav class=sidebar-nav > <a class="sidebar-nav-item " href="/marginalia/">Home</a> <a class="sidebar-nav-item " href="/marginalia/julia/">Julia</a> <a class="sidebar-nav-item " href="/marginalia/older-posts/">Older posts</a> </nav> <div class=sidebar-item > <p>&copy; JÃ¼rgen Fuhrmann.</p> </div> </div> <!-- Wrap is the content to shift when toggling the sidebar. We wrap the content to avoid any CSS collisions with our real content. --> <div class=wrap > <div class=masthead > <div class=container > <h3 class=masthead-title > <a href="/marginalia/" title=Home >Marginalia</a> </h3> </div> </div> </div> <div class="container content"> <div class=franklin-content ><h1>Julia Workflow Hints</h1> <p><div class=franklin-toc ><ol><li><a href="#never_leave_julia_and_write_code_in_functions">Never leave Julia and write code in functions</a><li><a href="#use_revisejl_to_reload_modified_code">Use Revise.jl to reload modified code</a><li><a href="#record_your_project_dependencies_in_reproducible_environments">Record your project dependencies in reproducible environments</a><li><a href="#take_advantage_of_julias_package_management_to_structure_larger_projects">Take advantage of Julia&#39;s package management to structure larger projects</a><li><a href="#tldr">TL;DR</a></ol></div> </p> <p>These workflow hints have been developed from my own experience and are essentially an illustration of the <a href="https://docs.julialang.org/en/v1/manual/workflow-tips">workflow tips</a> found in the Julia documentation. The ideas on project structuring are partially inspired by B. Kaminski&#39;s post on <a href="https://bkamins.github.io/julialang/2020/05/18/project-workflow.html">project workflow</a> and the <a href="https://github.com/JuliaDynamics/DrWatson.jl">DrWatson.jl</a> package by G. Datseris.</p> <h2 id=never_leave_julia_and_write_code_in_functions ><a href="#never_leave_julia_and_write_code_in_functions" class=header-anchor >Never leave Julia and write code in functions</a></h2> <p>Many available Julia examples and the mindset influenced by Matlab or Python suggest that code is written in scripts where computations are performed in the global context. E.g. a script <code>MyScript.jl</code> would look like:</p> <pre><code class="julia hljs"><span class=hljs-keyword >using</span> Package1
<span class=hljs-keyword >using</span> Package2

<span class=hljs-comment ># computations here</span>
...</code></pre> <p>and executed like</p> <pre><code class="julia hljs">$ julia MyScript.jl</code></pre>
<p>However, for Julia this is a bad idea for at  least two reasons:</p>
<ul>
<li><p>Type-stable action of Julia&#39;s just-in-time compiler is possible only for functions, so this code does not optimize well</p>

<li><p>One encounters precompilation time hiatus when running after each modified  version</p>

</ul>
<p>Suggestions:</p>
<ul>
<li><p><a href="https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-global-variables">Avoid global variables</a> and develop any code in functions. E.g. <code>MyScript.jl</code> could look like:</p>

</ul>
<pre><code class="julia hljs"><span class=hljs-keyword >using</span> Package1
<span class=hljs-keyword >using</span> Package2

<span class=hljs-keyword >function</span> main(; kwarg1=<span class=hljs-number >1</span>, kwarg2=<span class=hljs-number >2</span>)
 <span class=hljs-comment ># action here </span>
<span class=hljs-keyword >end</span></code></pre>
<ul>
<li><p>Always invoke the code from within a running julia instance. In this   case you encounter the <a href="https://docs.julialang.org/en/v1/manual/workflow-tips/#REPL-based-workflow">Read-Eval-Print-Loop &#40;REPL&#41;</a> of Julia. You don&#39;t need to leave julia for restarting modified code &#40;except in the case when you re-define a constant or a struct&#41;. Just reload the code by repeating the <code>include</code> statement:</p>

</ul>
<pre><code class="julia hljs">$ julia
julia&gt; include(<span class=hljs-string >&quot;MyScript.jl&quot;</span>)
julia&gt; main(kwarg1=<span class=hljs-number >5</span>)</code></pre>
<ul>
<li><p>Think about wrapping code into modules. The previous example can be enhanced by wrapping the code of the script into a module.  This has the advantage that you can load different scripts into the same session without name clashes.</p>

</ul>
<pre><code class="julia hljs"><span class=hljs-built_in >Module</span> MyScript

<span class=hljs-keyword >using</span> Package1
<span class=hljs-keyword >using</span> PackageN

<span class=hljs-keyword >function</span> main(; kwarg1=<span class=hljs-number >1</span>, kwarg2=<span class=hljs-number >2</span>)
 <span class=hljs-comment ># action here </span>
<span class=hljs-keyword >end</span>

<span class=hljs-keyword >end</span></code></pre>
<pre><code class="julia hljs">$ julia
julia&gt; include(<span class=hljs-string >&quot;MyScript.jl&quot;</span>)
julia&gt; MyScript.main(kwarg1=<span class=hljs-number >5</span>)</code></pre>
<h2 id=use_revisejl_to_reload_modified_code ><a href="#use_revisejl_to_reload_modified_code" class=header-anchor >Use Revise.jl to reload modified code</a></h2>
<p>In the previous examples, re-loading the code after modifications required to re-run the include statement. The package <a href="https://github.com/timholy/Revise.jl">Revise.jl</a> exports a function <code>includet</code> which triggers automatic recompilation  if the source code of the script file or of packages used therein has been modified.</p>
<p>In order to set this up, place the following into the Julia startup file <code>.julia/config/startup.jl</code> in your home directory:</p>
<pre><code class="julia hljs"><span class=hljs-keyword >using</span> Revise</code></pre>
<p>You would then run:</p>
<pre><code class="julia hljs">$ julia -i
julia&gt; includet(<span class=hljs-string >&quot;MyScript.jl&quot;</span>)
julia&gt; MyScript.main(kwarg1=<span class=hljs-number >5</span>)</code></pre>
<p>After having modified <code>MyScript.jl</code>, just another  invocation of <code>MyScript.main&#40;&#41;</code>  would see the changes. See also the corresponding hints in the <a href="https://docs.julialang.org/en/v1/manual/workflow-tips/#Revise-based-workflows">Julia documentation</a>.</p>
<p>Besides of tracking scripts loaded into the REPL, <code>Revise.jl</code> </p>
<ul>
<li><p>tracks changes in packages under development loaded into the script via <code>using</code> or <code>import</code>.</p>

<li><p>works in <a href="https://github.com/fonsp/Pluto.jl">Pluto notebooks</a></p>

</ul>
<h2 id=record_your_project_dependencies_in_reproducible_environments ><a href="#record_your_project_dependencies_in_reproducible_environments" class=header-anchor >Record your project dependencies in reproducible environments</a></h2>
<p>By default, packages added to the Julia installation are recorded in the default <em>global environment</em>:</p>
<pre><code class="julia hljs">$ julia
julia&gt;]
pkg&gt; add Package1</code></pre>
<p>This results in  corresponding entries in <code>.julia/environments/vx.y/Project.toml</code>  and <code>.julia/environments/vy.y/Manifest.toml</code>  &#40;where <code>x.y</code> stands for your installed Julia version&#41;. Sharing this global  environment between all your different projects is risky because of possible conflicts in package version requirements. In addition, relying on the global environment makes it hard to share your code with others, as you would have to find a way to communicate the names of the  packages &#40;with versions&#41; which they need to install to run your code.</p>
<p><em>Local environments</em> provide a remedy.</p>
<p>Assume that a <em>project</em> is Julia code residing in a given directory <code>MyProject</code>, uses one or several other Julia packages and is not intended to be invoked from other projects. An environment is described by the two files in the <code>MyProject</code> directory: <code>Project.toml</code> and <code>Manifest.toml</code>. Set up an environment in the following way:</p>
<pre><code class="julia hljs">$ cd MyProject
$ julia
$ pkg&gt; activate .
$ pkg&gt; add Package1
$ pkg&gt; add PackageN
$ exit()</code></pre>
<p>After setting up the environment like this, you can  perform</p>
<pre><code class="julia hljs">$ cd MyProject
$ julia --project=.</code></pre>
<p>and work in the environment. All packages added  to Julia in this case are recorded in <code>MyProject</code> instead of <code>.julia/environments/vx.y/</code>. Packages in the global environment still will be visible to your project.</p>
<p>The <code>Project.toml</code> file lists the packages added to the environment. In addition, a <code>Manifest.toml</code> file appears which holds the information about the exact versions of all Julia packages used by the project. Both  should be checked into version control along with the source code. If you took care about adding all necessary dependencies to the local environment, after checking out your code, another project collaborator can easily install all dependencies via</p>
<pre><code class="julia hljs">$ cd MyProject
$ julia --project=.
$ pkg&gt; instantiate</code></pre>
<p>See also the corresponding documentation on <a href="https://pkgdocs.julialang.org/v1/environments/">environments</a> and <a href="https://pkgdocs.julialang.org/v1/toml-files/"><code>Project.toml</code> and <code>Manifest.toml</code></a>.</p>
<p>Pluto notebooks have their own <a href="https://github.com/fonsp/Pluto.jl/wiki/&#37;F0&#37;9F&#37;8E&#37;81-Package-management">built-in package management</a> and by default     contain a <code>Project.toml</code> and a <code>Manifest.toml</code> file to ensure portability.</p>
<h2 id=take_advantage_of_julias_package_management_to_structure_larger_projects ><a href="#take_advantage_of_julias_package_management_to_structure_larger_projects" class=header-anchor >Take advantage of Julia&#39;s package management to structure larger projects</a></h2>
<p>Up to now, it was assumed that one works with a couple of scripts in a subdirectory. For a larger project, more structure of the code is needed:</p>
<ul>
<li><p>different project scripts and Pluto notebooks may share some parts of the code, and you want to avoid <a href="https://en.wikipedia.org/wiki/Don&#37;27t_repeat_yourself">repeating yourself</a></p>

<li><p>modularization of the project code can facilitate maintenance and extendability</p>

<li><p>may be some of the code slowly turns into a package</p>

<li><p>you want to have unit testing available in the project</p>

<li><p>the whole project directory <em>still</em> shall be shareable with collaborators in a reproducible way</p>

</ul>
<p>The following recommendations are partially inspired by B. Kaminski&#39;s post on  <a href="https://bkamins.github.io/julialang/2020/05/18/project-workflow.html">project workflow</a> and  the  <a href="https://github.com/JuliaDynamics/DrWatson.jl">DrWatson.jl</a> package by G. Datseris.</p>
<ul>
<li><p>Generate the project directory itself as a package &#40;named e.g. <code>MyProject</code>&#41; using <a href="https://pkgdocs.julialang.org/v1/creating-packages/"><code>Pkg.generate</code></a> or <a href="https://github.com/invenia/PkgTemplates.jl">PkgTemplates.jl</a>. This has the following advantages:</p>
<ul>
<li><p>easy way to share  the code in the <code>src</code> folder among different project scripts via <code>using MyProject</code></p>

<li><p>availability of Julia&#39;s  test and documentation functionality for the project</p>

</ul>

<li><p>Optionally have a folder <code>packages</code> which contains other sub-packages. As <a href="https://github.com/JuliaLang/Pkg.jl/issues/1214">relative paths are recorded in Manifest.toml</a>, these can be made available the project via <code>Pkg.develop&#40;path&#61;&quot;packages/MySubPackage&quot;&#41;</code>. In this case, the whole project  tree will stay relocateable.</p>
<ul>
<li><p>This allows for easy start of low key package development. At a later stage, <code>MySubPackage</code> could be registered as a Julia package while still residing in the project teee, or even removed from the project tree without affecting  scripts depending on it. </p>

</ul>

<li><p>When working with the project, always run julia from the package root with the package environment activated: <code>julia --project&#61;.</code> </p>

<li><p>Assume project specific Pluto notebooks to reside in a <code>notebooks</code> subdirectory  and call <code>Pkg.activate&#40;joinpath&#40;@__DIR__,&quot;..&quot;&#41;&#41;</code> in their respective Pkg cell to activate the <code>MyProject</code> environment.  As a consequence, Pluto&#39;s in-built package manager will be disabled and the project specific notebooks will share the <code>MyProject</code> environment and <em>cannot be shared independent from the <code>MyProject</code> tree</em> &#40;If independent sharing is desired, common project code can be collected into a package residing in <code>packages</code> and registered in a registry; registering <code>MyProject</code> itself as a package is not recommended.  â More about this in another post&#41;.</p>

<li><p>You may use <a href="https://github.com/JuliaDynamics/DrWatson.jl">DrWatson.jl</a> for managing subdirectory access, simulation results and version tagging. By explicitely activating the project environment at the start of Julia or in the notebook Pkg cell, you can avoid <code>@quickactivate</code> and  avoid putting <code>using DrWatson</code> into script files and notebooks for the sole purpose of activating the common environment. See also <a href="https://github.com/JuliaDynamics/DrWatson.jl/issues/261">this discussion</a>.</p>

</ul>
<p>A sample project tree could e.g. look like this</p>
<pre><code class="julia hljs">MyProject
âââ LICENSE
âââ Manifest.toml
âââ notebooks
âÂ Â  âââ demo-notebook.jl
âââ packages
âÂ Â  âââ MySubPackage
âÂ Â      âââ Manifest.toml
âÂ Â      âââ Project.toml
âÂ Â      âââ src
âÂ Â      âÂ Â  âââ MySubPackage.jl
âÂ Â      âââ test
âÂ Â          âââ runtests.jl
âââ papers
âââ Project.toml
âââ README.md
âââ scripts
âÂ Â  âââ demo-script.jl
âââ src
âÂ Â  âââ MyProject.jl
âââ test
    âââ runtests.jl</code></pre>
<p>You can download the Julia script <a href="/marginalia/assets/genproject.jl">genproject.jl</a> and generate this structure a subdirectory on your computer via</p>
<pre><code class="julia hljs">julia --compile=min genproject.jl name_of_your_project</code></pre>
<p>Feel free to adapt the generated directory tree to your needs and don&#39;t forget to make a git repository out of it as early as possible.</p>
<h2 id=tldr ><a href="#tldr" class=header-anchor >TL;DR</a></h2>
<ul>
<li><p>Script functionality should be developed in functions, avoiding global variables</p>

<li><p>Create a project specific environment as a project-package</p>

<li><p>Use the REPL and  Revise.jl, start julia in the activated project environment</p>

<li><p>Place shared code among project specific  scripts or  notebooks either in the <code>src</code> subdirectory as part of the project-package, or in a  sub-package in a subdirectory of the project-package</p>

<li><p>Separate namespaces of scripts by using  modules</p>

<li><p>Activate the shared project environment of the project-package in project specific Pluto notebooks. </p>

<li><p>Write tests and examples</p>

</ul>
<p>By taking advantage of Julia&#39;s best-in-class package management facilities, the proposed approach goes a long way in the direction of maintaining sustainable research software. From a <a href="https://de.slideshare.net/andreas.zeller/sustainable-research-software">talk by A. Zeller</a>:</p>
<ol>
<li><p>Have a repo â</p>

<li><p>Anyone can build â</p>

<li><p>Have tests â</p>

<li><p>Be open for extensions â</p>

<li><p>Have examples â</p>

</ol>
<div class=page-foot >
  <div class=copyright >
    &copy; JÃ¼rgen Fuhrmann. License: <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode"> CC-BY-SA 4.0</a>. Last modified: November 14, 2021. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>.
Upon finding factual errors, typos etc. <a href=https://github.com/j-fu/marginalia/issues> raise an issue<a>.
  </div>
</div>


</div>
      </div>  
    </div> 
    
    
        


    
    <label for=sidebar-checkbox  class=sidebar-toggle ></label>