<?xml version="1.0" encoding="UTF-8"?>

<rss version="2.0"
  xmlns:content="http://purl.org/rss/1.0/modules/content/"
  xmlns:dc="http://purl.org/dc/elements/1.1/"
  xmlns:media="http://search.yahoo.com/mrss/"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:georss="http://www.georss.org/georss">

  <channel>
    <title>
      <![CDATA[  Marginalia  ]]>
    </title>
    <link> https://j-fu.github.io/marginalia/ </link>
    <description>
      <![CDATA[  Remarks on computing &amp; stuff  ]]>
    </description>
    <atom:link
      href="https://j-fu.github.io/marginalia/feed.xml"
      rel="self"
      type="application/rss+xml" />


<item>
  <title>
    <![CDATA[  Julia: Project Workflow  ]]>
  </title>
  <link> https://j-fu.github.io/marginalia/julia/project-workflow/index.html </link>
  <guid> https://j-fu.github.io/marginalia/julia/project-workflow/index.html </guid>
  <description>
    <![CDATA[  Julia: Project Workflow.  ]]>
  </description>  
  
  <content:encoded>
    <![CDATA[  <h1 id="julia_project_workflow">Julia: Project Workflow</h1>
<ul>
<li><p>2022-02-09: RSS</p>
</li>
<li><p>2021-12-02: The term &quot;project&quot; in this post corresponds to the term &quot;application&quot; in <a href="https://pkgdocs.julialang.org/v1/glossary/#Glossary">package manager glossary</a>.</p>
</li>
<li><p>2021-11-15: Initial version </p>
</li>
</ul>
<p>Some ideas on basic julia workflow  are given  <a href="https://j-fu.github.io/marginalia/julia/basic-workflow">here</a>. For a larger project, structuring of the project code is essential for many reasons, some of them are:</p>
<ul>
<li><p>Different project scripts and Pluto notebooks may share some parts of the code, and you want to avoid <a href="https://en.wikipedia.org/wiki/Don&#37;27t_repeat_yourself">repeating yourself</a>.</p>
</li>
<li><p>Modularization of the project code should facilitate maintainability and extendability.</p>
</li>
<li><p>May be some of the code slowly turns into a package.</p>
</li>
<li><p>You want to have unit testing available in the project.</p>
</li>
<li><p>The whole project directory <em>still</em> shall be shareable with collaborators in a reproducible way.</p>
</li>
</ul>
<p>The following recommendations are partially inspired by B. Kaminski&#39;s post on  <a href="https://bkamins.github.io/julialang/2020/05/18/project-workflow.html">project workflow</a> and  the  <a href="https://github.com/JuliaDynamics/DrWatson.jl">DrWatson.jl</a> package by G. Datseris.</p>
<ul>
<li><p>Generate the project directory itself as a package &#40;named e.g. <code>MyProject</code>&#41; using <a href="https://pkgdocs.julialang.org/v1/creating-packages/"><code>Pkg.generate</code></a> or <a href="https://github.com/invenia/PkgTemplates.jl">PkgTemplates.jl</a>. This  <em>project-package</em> will remain unregistered, its code will be shared directly via git repository urls.  Developing the project in such a project-package has the following advantages:</p>
<ul>
<li><p>Straightforward way to share  the code in the <code>src</code> folder among different project scripts and notebooks based on one shared environment via <code>using MyProject</code>.</p>
</li>
<li><p>Straightforward availability of Julia&#39;s  test and documentation functionality for the project.</p>
</li>
</ul>
</li>
<li><p>Optionally have a folder <code>packages</code> which contains other sub-packages which potentially can evolve into standalone, registered packages. As <a href="https://github.com/JuliaLang/Pkg.jl/issues/1214">relative paths are recorded in Manifest.toml</a>, these are made available within the  project via <code>Pkg.develop&#40;path&#61;&quot;packages/MySubPackage&quot;&#41;</code>. This way, the  whole project  tree including sub-packages  will stay relocateable.</p>
<ul>
<li><p>This allows for easy start of low key package development. At a later stage, <code>MySubPackage</code> could be registered as a Julia package while still residing in the project tree, or even removed from the project tree without affecting  scripts depending on it – once registered, the package can be added in to the project environment via <code>Pkg.add</code> instead of <code>Pkg.develop</code>.</p>
</li>
</ul>
</li>
<li><p>When working with the project, always run julia from the package root with the package environment activated: <code>julia --project&#61;.</code> </p>
</li>
<li><p>Assume project specific Pluto notebooks to reside in a <code>notebooks</code> subdirectory  and call <code>Pkg.activate&#40;joinpath&#40;@__DIR__,&quot;..&quot;&#41;&#41;</code> in their respective Pkg cell to activate the <code>MyProject</code> environment.  As a consequence, Pluto&#39;s in-built package manager will be disabled and the project specific notebooks will share the <code>MyProject</code> environment and <em>cannot be shared independent from the <code>MyProject</code> tree</em> &#40;If independent sharing is desired, common project code can be collected into a package residing in <code>packages</code> and registered in a registry; registering <code>MyProject</code> itself as a package is not recommended.  – More about this in another post&#41;.</p>
</li>
</ul>
<ul>
<li><p>You may use <a href="https://github.com/JuliaDynamics/DrWatson.jl">DrWatson.jl</a> for managing subdirectory access, simulation results and version tagging. By explicitely activating the project environment at the start of Julia or in the notebook Pkg cell, you can avoid <code>@quickactivate</code> and  avoid putting <code>using DrWatson</code> into script files and notebooks for the sole purpose of activating the common environment. See also <a href="https://github.com/JuliaDynamics/DrWatson.jl/issues/261">this discussion</a>.</p>
</li>
</ul>
<p>A sample project tree could e.g. look like this</p>
<pre><code class="language-julia">MyProject
├── LICENSE
├── Manifest.toml
├── notebooks
│   └── demo-notebook.jl
├── packages
│   └── MySubPackage
│       ├── Manifest.toml
│       ├── Project.toml
│       ├── src
│       │   └── MySubPackage.jl
│       └── test
│           └── runtests.jl
├── papers
├── Project.toml
├── README.md
├── scripts
│   └── demo-script.jl
├── src
│   └── MyProject.jl
└── test
    └── runtests.jl</code></pre>
<p>You can download the Julia script <a href="https://j-fu.github.io/marginalia/assets/genproject.jl">genproject.jl</a> and generate this structure a subdirectory on your computer via</p>
<pre><code class="language-julia">julia --compile&#61;min genproject.jl name_of_your_project</code></pre>
<p>Feel free to adapt the generated directory tree to your needs and don&#39;t forget to make a git repository out of it as early as possible.</p>
<h2 id="summary">Summary</h2>
<ul>
<li><p>Script functionality should be developed in functions, avoiding global variables</p>
</li>
<li><p>Create a project specific environment as a project-package</p>
</li>
<li><p>Use the REPL and  Revise.jl, start julia in the activated project environment</p>
</li>
<li><p>Place shared code among project specific  scripts or  notebooks either in the <code>src</code> subdirectory as part of the project-package, or in a  sub-package in a subdirectory of the project-package</p>
</li>
<li><p>Separate namespaces of scripts by using  modules</p>
</li>
<li><p>Activate the shared project environment of the project-package in project specific Pluto notebooks. </p>
</li>
<li><p>Write tests and examples</p>
</li>
</ul>
<p>By taking advantage of Julia&#39;s best-in-class package management facilities, the proposed approach goes a long way in the direction of maintaining sustainable research software. From a <a href="https://de.slideshare.net/andreas.zeller/sustainable-research-software">talk by A. Zeller</a>:</p>
<ol>
<li><p>Have a repo ✓</p>
</li>
<li><p>Anyone can build ✓</p>
</li>
<li><p>Have tests ✓</p>
</li>
<li><p>Be open for extensions ✓</p>
</li>
<li><p>Have examples ✓</p>
</li>
</ol>
 ]]>
  </content:encoded>
    
  <pubDate>Wed, 09 Feb 2022 00:00:00 +0000</pubDate>  
  
  
  <atom:author>
    <atom:name>Jürgen Fuhrmann</atom:name>
  </atom:author>
        
</item>

<item>
  <title>
    <![CDATA[  Julia: Basic Workflow  ]]>
  </title>
  <link> https://j-fu.github.io/marginalia/julia/basic-workflow/index.html </link>
  <guid> https://j-fu.github.io/marginalia/julia/basic-workflow/index.html </guid>
  <description>
    <![CDATA[  Julia: Basic Workflow.  ]]>
  </description>  
  
  <content:encoded>
    <![CDATA[  <h1 id="julia_basic_workflow">Julia: Basic Workflow</h1>
<ul>
<li><p>2022-02-09: RSS</p>
</li>
<li><p>2021-11-15: Initial version</p>
</li>
</ul>
<p><div class="franklin-toc"><ol><li>Never leave Julia and  write code in functions</li><li>Use Revise.jl to reload modified code</li><li>Record your project dependencies in reproducible environments</li></ol></div> </p>
<p>These workflow hints have been developed from my own experience and are essentially an illustration of the <a href="https://docs.julialang.org/en/v1/manual/workflow-tips">workflow tips</a>  found in the Julia documentation. </p>
<h2 id="never_leave_julia_and_write_code_in_functions">Never leave Julia and  write code in functions</h2>
<p>Many available Julia examples and  the mindset influenced by Matlab or Python suggest  that code is written in scripts where  computations are performed in the global context. E.g.  a script <code>MyScript.jl</code> would look like:</p>
<pre><code class="language-julia">using Package1
using Package2# computations here
...</code></pre>
<p>and executed like</p>
<pre><code class="language-julia">&#36; julia MyScript.jl</code></pre>
<p>However, for Julia this is a bad idea for at  least two reasons:</p>
<ul>
<li><p>Type-stable action of Julia&#39;s just-in-time compiler is possible only for functions, so this code does not optimize well</p>
</li>
<li><p>One encounters precompilation time hiatus when running after each modified  version</p>
</li>
</ul>
<p>Suggestions:</p>
<ul>
<li><p><a href="https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-global-variables">Avoid global variables</a> and develop any code in functions. E.g. <code>MyScript.jl</code> could look like:</p>
</li>
</ul>
<pre><code class="language-julia">using Package1
using Package2function main&#40;; kwarg1&#61;1, kwarg2&#61;2&#41;
 # action here 
end</code></pre>
<ul>
<li><p>Always invoke the code from within a running julia instance. In this   case you encounter the <a href="https://docs.julialang.org/en/v1/manual/workflow-tips/#REPL-based-workflow">Read-Eval-Print-Loop &#40;REPL&#41;</a> of Julia. You don&#39;t need to leave julia for restarting modified code &#40;except in the case when you re-define a constant or a struct&#41;. Just reload the code by repeating the <code>include</code> statement:</p>
</li>
</ul>
<pre><code class="language-julia">&#36; julia
julia&gt; include&#40;&quot;MyScript.jl&quot;&#41;
julia&gt; main&#40;kwarg1&#61;5&#41;</code></pre>
<ul>
<li><p>Think about wrapping code into modules. The previous example can be enhanced by wrapping the code of the script into a module.  This has the advantage that you can load different scripts into the same session without name clashes.</p>
</li>
</ul>
<pre><code class="language-julia">Module MyScriptusing Package1
using PackageNfunction main&#40;; kwarg1&#61;1, kwarg2&#61;2&#41;
 # action here 
endend</code></pre>
<pre><code class="language-julia">&#36; julia
julia&gt; include&#40;&quot;MyScript.jl&quot;&#41;
julia&gt; MyScript.main&#40;kwarg1&#61;5&#41;</code></pre>
<h2 id="use_revisejl_to_reload_modified_code">Use Revise.jl to reload modified code</h2>
<p>In the previous examples, re-loading the code after modifications required to re-run the include statement. The package <a href="https://github.com/timholy/Revise.jl">Revise.jl</a> exports a function <code>includet</code> which triggers automatic recompilation  if the source code of the script file or of packages used therein has been modified.</p>
<p>In order to set this up, place the following into the Julia startup file <code>.julia/config/startup.jl</code> in your home directory:</p>
<pre><code class="language-julia">using Revise</code></pre>
<p>You would then run:</p>
<pre><code class="language-julia">&#36; julia -i
julia&gt; includet&#40;&quot;MyScript.jl&quot;&#41;
julia&gt; MyScript.main&#40;kwarg1&#61;5&#41;</code></pre>
<p>After having modified <code>MyScript.jl</code>, just another  invocation of <code>MyScript.main&#40;&#41;</code>  would see the changes. See also the corresponding hints in the <a href="https://docs.julialang.org/en/v1/manual/workflow-tips/#Revise-based-workflows">Julia documentation</a>.</p>
<p>Besides of tracking scripts loaded into the REPL, <code>Revise.jl</code> </p>
<ul>
<li><p>tracks changes in packages under development loaded into the script via <code>using</code> or <code>import</code>.</p>
</li>
<li><p>works in <a href="https://github.com/fonsp/Pluto.jl">Pluto notebooks</a></p>
</li>
</ul>
<h2 id="record_your_project_dependencies_in_reproducible_environments">Record your project dependencies in reproducible environments</h2>
<p>Update 2021-12-02: Modified terminology according to the <a href="https://pkgdocs.julialang.org/v1/glossary/#Glossary">Pkg Glossary</a>: replaced &quot;project&quot; by &quot;application&quot;.</p>
<p>By default, packages added to the Julia installation are recorded in the default <em>global environment</em>:</p>
<pre><code class="language-julia">&#36; julia
julia&gt;&#93;
pkg&gt; add Package1</code></pre>
<p>This results in  corresponding entries in <code>.julia/environments/vx.y/Project.toml</code>  and <code>.julia/environments/vy.y/Manifest.toml</code>  &#40;where <code>x.y</code> stands for your installed Julia version&#41;. Sharing this global  environment between all your different projects is risky because of possible conflicts in package version requirements. In addition, relying on the global environment makes it hard to share your code with others, as you would have to find a way to communicate the names of the  packages &#40;with versions&#41; which they need to install to run your code.</p>
<p><em>Local environments</em> provide a remedy.</p>
<p>Assume that an  <em>application</em> is Julia code residing in a given directory <code>MyApp</code>, uses one or several other Julia packages and is not intended to be invoked from other packages or applications. An environment is described by the two files in the <code>MyApp</code> directory: <code>Project.toml</code> and <code>Manifest.toml</code>. Set up an environment in the following way:</p>
<pre><code class="language-julia">&#36; cd MyApp
&#36; julia
&#36; pkg&gt; activate .
&#36; pkg&gt; add Package1
&#36; pkg&gt; add PackageN
&#36; exit&#40;&#41;</code></pre>
<p>After setting up the environment like this, you can  perform</p>
<pre><code class="language-julia">&#36; cd MyApp
&#36; julia --project&#61;.</code></pre>
<p>and work in the environment. All packages added  to Julia in this case are recorded in <code>MyApp</code> instead of <code>.julia/environments/vx.y/</code>. Packages in the global environment still will be visible to your project.</p>
<p>The <code>Project.toml</code> file lists the packages added to the environment. In addition, a <code>Manifest.toml</code> file appears which holds the information about the exact versions of all Julia packages used by the project. Both  should be checked into version control along with the source code. If you took care about adding all necessary dependencies to the local environment, after checking out your code, another project collaborator can easily install all dependencies via</p>
<pre><code class="language-julia">&#36; cd MyApp
&#36; julia --project&#61;.
&#36; pkg&gt; instantiate</code></pre>
<p>See also the corresponding documentation on <a href="https://pkgdocs.julialang.org/v1/environments/">environments</a> and <a href="https://pkgdocs.julialang.org/v1/toml-files/"><code>Project.toml</code> and <code>Manifest.toml</code></a>.</p>
<p>Pluto notebooks have their own <a href="https://github.com/fonsp/Pluto.jl/wiki/&#37;F0&#37;9F&#37;8E&#37;81-Package-management">built-in package management</a> and by default     contain a <code>Project.toml</code> and a <code>Manifest.toml</code> file to ensure portability.</p>
 ]]>
  </content:encoded>
    
  <pubDate>Wed, 09 Feb 2022 00:00:00 +0000</pubDate>  
  
  
  <atom:author>
    <atom:name>Jürgen Fuhrmann</atom:name>
  </atom:author>
        
</item>

<item>
  <title>
    <![CDATA[  Julia: Achieving Performance   ]]>
  </title>
  <link> https://j-fu.github.io/marginalia/julia/achieving-performance/index.html </link>
  <guid> https://j-fu.github.io/marginalia/julia/achieving-performance/index.html </guid>
  <description>
    <![CDATA[  Julia: Achieving Performance.  ]]>
  </description>  
  
  <content:encoded>
    <![CDATA[  <h1 id="julia_achieving_performance">Julia: Achieving Performance </h1>
<ul>
<li><p>2022-02-09: RSS</p>
</li>
<li><p>2021-11-15: Initial version</p>
</li>
</ul>
<div class="franklin-toc"><ol><li>Other resources on this topic</li><li>&quot;Measure performance with @time and pay attention to memory allocations&quot;</li><li>&quot;REPL based workflow&quot;</li><li>&quot;Avoid global variables&quot;</li><li>&quot;Pre-allocate outputs&quot;</li><li>&quot;Avoid changing the type of a variable&quot; </li><li>&quot;More dots: fuse vectorized operations&quot;</li><li>&quot;Be aware of when Julia avoids specializing&quot;</li><li>&quot;Performance annotations&quot;</li></ol></div>
<p>In  order  to  let  newcomers  to the  language  experience  the  real performance potential of Julia it  is important to raise the awareness for the corresponding &quot;tricks&quot; early on.</p>
<p>This text results from an effort  to improve the code performance of a piece  of experimental  research  code  which has  been  written by  a colleague new  to Julia. It   describes the steps  taken  to  get runtime down from 13s to 0.07s and allocations form 763.08 M allocations to 86.</p>
<h2 id="other_resources_on_this_topic">Other resources on this topic</h2>
<ul>
<li><p>It turned out that all necessary information is described on the <a href="https://docs.julialang.org/en/v1/manual/performance-tips/#man-performance-tips">Julia performance tips</a> page, this text should be understood as an additional explanation from a bit different angle and a bit more in layman&#39;s terms.  The corresponding links to the documentation sections are provided.</p>
</li>
<li><p>Also, the <a href="https://www.stochasticlifestyle.com/7-julia-gotchas-handle/">7 Julia Gotchas</a> still are worth to read in this context.</p>
</li>
<li><p>UPDATE 2021-12-01: <a href="https://blog.sintef.com/industry-en/writing-type-stable-julia-code/">Writing type-stable Julia code</a></p>
</li>
</ul>
<h2 id="measure_performance_with_time_and_pay_attention_to_memory_allocations">&quot;Measure performance with @time and pay attention to memory allocations&quot;</h2>
<p><a href="https://docs.julialang.org/en/v1/manual/performance-tips/#Measure-performance-with-&#91;@time&#93;&#40;@ref&#41;-and-pay-attention-to-memory-allocatioan">Julia docs 🔗</a></p>
<p>One allocation can use the time of several hundred floating point multiplications. </p>
<p>In order to understand the role of allocations ist is useful to  understand the concept of <a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html#the-stack-and-the-heap">stack and heap</a>, which is fundamental for any modern computer language &#40;as e.g. for Rust in the previous link&#41;.</p>
<p>An allocation reserves memory from the memory pool of the operating system &#40;&quot;heap&quot;&#41; and is expensive  as the  interaction  with the  operating  system  kernel needs certain amount of bookkeeping. Fundamentally, an allocation happens in  any language when  creating an object of a priori unknown size, e.g. an  array of length unknown at compile time. Objects with a priori known size, as e.g. structs  can be placed on top of a piece of memory pre-allocated during program start called &quot;stack&quot;, with almost no bookkeeping as no allocation from the system is necessary.</p>
<p>In Julia, the  <a href="https://docs.julialang.org/en/v1/base/base/#Base.@time"><code>@time</code></a> macro can be used to find allocations. Besides the execution time it prints  the number of allocations happening when running  the measured expression. There is also the possibility to run the code with  <a href="https://docs.julialang.org/en/v1/manual/command-line-options/#command-line-options"><code>julia --track-allocation</code></a>.</p>
<p>The idea is then &quot;hunt&quot; allocations by placing temporary @time statements in critical places of the code. In particular, removing allocations from &quot;hot loops&quot; with will pay off. </p>
<h2 id="repl_based_workflow">&quot;REPL based workflow&quot;</h2>
<p><a href="https://docs.julialang.org/en/v1/manual/workflow-tips/#REPL-based-workflow">Julia docs 🔗</a> </p>
<p>During code development it is  helpful never to leave the Julia command line and to include the code after each change using the <code>include</code> statement. This approach avoids Just-in-time &#40;JIT&#41; recompilation which is peformed at startup time.</p>
<p>For more intense projects it is worth to use <a href="https://github.com/timholy/Revise.jl">Revise.jl</a> for automatic handling of code updates instead of calling <code>include</code> again and again.</p>
<p>Also it may be worth to have a look at the <a href="https://www.julia-vscode.org/">Visual Studio Code</a> editing environment for working with Julia.</p>
<h2 id="avoid_global_variables">&quot;Avoid global variables&quot;</h2>
<p><a href="https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-global-variables">Julia docs 🔗</a></p>
<p>Avoid to work with global variables. E.g. instead of</p>
<pre><code class="language-julia">a&#61;10
b&#61;11function important&#40;x&#41;
   x&#61;5*a&#43;b
endimportant&#40;10&#41;</code></pre>
<p>write</p>
<pre><code class="language-julia">a&#61;10
b&#61;11function important&#40;x,a,b&#41;
     x&#61;5*a&#43;b
end
important&#40;10,a,b&#41;</code></pre>
<p>A more profound approach which would keep parameter lists  short may be the creation of a context <code>struct</code> which collects the parameters.</p>
<p>Alternatively, wrap the global context into a function </p>
<pre><code class="language-julia">function run&#40;&#41;
  a::Int&#61;10
  b::Int&#61;11  function important&#40;x&#41;
     x&#61;5*a&#43;b
  end
  important&#40;10&#41;
end</code></pre>
<p>and ensure that <a href="https://docs.julialang.org/en/v1/manual/performance-tips/#man-performance-captured"><code>a</code> and <code>b</code> never change type</a> by <a href="https://docs.julialang.org/en/v1/manual/types/#Type-Declarations">type-annotating</a> them &#40;which is not possible for global variables&#41;.</p>
<h5 id="rationale">Rationale:</h5>
<p>Julia assumes that a global variable can change its type anytime, so it needs to be wrapped  into a container &#40;&quot;boxing&quot;&#41; labeled with its current type. Handling these is expensive and manifests itself in additional allocations. Type changes of captured variables would have similar implications. In fact, this is very similar to the way e.g. python works with <em>any</em> variable.</p>
<h2 id="pre-allocate_outputs">&quot;Pre-allocate outputs&quot;</h2>
<p><a href="https://docs.julialang.org/en/v1/manual/performance-tips/#Pre-allocating-outputs">Julia docs 🔗</a></p>
<p>Pre-allocate memory e.g. for arrays needed in inner loops. In the case where array sizes are unknown a priori,  replace expressions like <code>F&#61;&#91;something&#40;i&#41; for i&#61;1:N&#93;</code>  by </p>
<pre><code class="language-julia">function Fnum&#40;F&#41;
  ...
  if length&#40;F&#41;&lt;N
    resize&#33;&#40;F,N&#41;
  end
  for i&#61;1:N 
     F&#91;i&#93;&#61;something&#40;i&#41;
  end
  ...  
end</code></pre>
<p>where <code>F</code> is initialized e.g. via <code>F&#61;zeros&#40;0&#41;</code> is created once and passed to <code>FNum</code>. </p>
<h5 id="rationale__2">Rationale:</h5>
<p>An expression like <code>F&#61;&#91;...&#93;</code> creates an array and allocates memory for it. If this happens for a temporay variable used in a function called many times, this becomes a massive performance hit. Therefore, it is better  to pre-allocate this   memory, pass it to the inner loop function and to  increase it on necessity &#40;leading only to few allocations if the hitherto length was too short&#41;.</p>
<h2 id="avoid_changing_the_type_of_a_variable">&quot;Avoid changing the type of a variable&quot; </h2>
<p><a href="https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-changing-the-type-of-a-variable">Julia docs 🔗</a></p>
<p>Replace <code>x&#61;0</code>, <code>x&#61;1</code>, etc. by <code>x&#61;0.0</code>, <code>x&#61;1.0</code> etc when it comes to declarations of variables later used as floating point values. </p>
<p>Another alternative is to <a href="https://docs.julialang.org/en/v1/manual/types/#Type-Declarations">type-annotate</a> variables when declaring them the first time: <code>x::FLoat64&#61;1</code>.</p>
<h5 id="rationale__3">Rationale:</h5>
<p>Setting <code>x&#61;1</code>, and writing  later <code>x&#61;2.0</code> changes the type of <code>x</code> and creates a <a href="https://docs.julialang.org/en/v1/manual/faq/#man-type-stability">type instability</a> with very much the same consequences as described above with respect to global variables. The <a href="https://docs.julialang.org/en/v1/manual/performance-tips/#man-code-warntype"><code>@code_warntype</code></a> macro can help to find corresponding situations.</p>
<h2 id="more_dots_fuse_vectorized_operations">&quot;More dots: fuse vectorized operations&quot;</h2>
<p><a href="https://docs.julialang.org/en/v1/manual/performance-tips/#More-dots:-Fuse-vectorized-operations">Julia docs 🔗</a></p>
<p>Replace vector expressions like </p>
<pre><code class="language-julia">u&#61;v-w</code></pre>
<p>by either </p>
<pre><code class="language-julia">u.&#61; v.-w</code></pre>
<p>or the equivalent </p>
<pre><code class="language-julia">@. u&#61;v-w</code></pre>
<h5 id="rationale__4">Rationale:</h5>
<p>Vector expressions without dot &quot;.&quot; result in handling each elementary expression in its own loop over vector length and creating  intermediate values which need to be allocated.</p>
<p>The dot tells Julia to <em>fuse</em> these loops, that means the Julia compiler creates exactly one loop which applies the operations component-wise instead of creating code for each operation apart. This removes multiple loop bookkeeping overheads and avoids allocation of memory for intermediate expressions.</p>
<p>Connected to his hint is the fact that unlike with python/numpy, in Julia there is no need to &quot;vectorize&quot; code for performance. Writing your own loops or writing fused vector expressions is sufficient to get full performance with Julia. </p>
<h2 id="be_aware_of_when_julia_avoids_specializing">&quot;Be aware of when Julia avoids specializing&quot;</h2>
<p><a href="https://docs.julialang.org/en/v1/manual/performance-tips/#Be-aware-of-when-Julia-avoids-specializing">Julia docs 🔗</a></p>
<p>Moving functions parametrizing the code from global variables to function parameters creates  a new source of allocations. This can be  removed by type-annotating the newly introduced function parameters.</p>
<p>E.g. for <code>func</code> being a function  parameter of <code>g</code>, replace</p>
<pre><code class="language-julia">function  g&#40;func, a,b,c&#41;
...
end</code></pre>
<p>by</p>
<pre><code class="language-julia">function   g&#40;func::T, a, b,c&#41; where &#123;T&#125;
...
end</code></pre>
<h4 id="rationale__5">Rationale:</h4>
<p>Usually, if Julia is aware of the types of parameters passed to a function, it  creates specialized code for each combination of type signatures. E.g.  with a definition <code>f&#40;x&#41;&#61;x*x</code> Julia is triggered to create  code for floating point numbers when calling <code>f&#40;2.0&#41;</code> and  for rational numbers when calling <code>f&#40;2//1&#41;</code>.  This behavior is called <em>specialization</em>.</p>
<p>There are exceptions to this rule. One exception are function parameters. Julia by default does not specialize on function parameter types &#40;in Julia, each function has its own type&#41;, resulting in an allocation when calling the first version of <code>g&#40;func,a,b,c&#41;</code>, even when the body of <code>g</code> is &quot;allocation free&quot;.</p>
<p>Type-annotating <code>func</code> in the parameter list of <code>g</code> with a <a href="https://docs.julialang.org/en/v1/base/base/#where">type parameter</a>  triggers Julia to create specialized code for each function passed.</p>
<h2 id="performance_annotations">&quot;Performance annotations&quot;</h2>
<p><a href="https://docs.julialang.org/en/v1/manual/performance-tips/#man-performance-annotations">Julia docs 🔗</a></p>
<p>Annotate  inner loops with <code>@fastmath @inbounds</code> to remove bounds checking and some speed constraints inherent to pure  IEEE floating point arithmetic.</p>
 ]]>
  </content:encoded>
    
  <pubDate>Wed, 09 Feb 2022 00:00:00 +0000</pubDate>  
  
  
  <atom:author>
    <atom:name>Jürgen Fuhrmann</atom:name>
  </atom:author>
        
</item>
</channel></rss>